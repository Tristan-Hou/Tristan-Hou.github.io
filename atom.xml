<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Tristan的博客</title>
  
  <subtitle>Tristan-Hou</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-09-11T14:09:21.676Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Tristan-Hou</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Android面试题答</title>
    <link href="http://yoursite.com/2018/09/11/Android%E9%9D%A2%E8%AF%95%E9%A2%98%E7%AD%94%E6%A1%88/"/>
    <id>http://yoursite.com/2018/09/11/Android面试题答案/</id>
    <published>2018-09-11T14:06:28.918Z</published>
    <updated>2018-09-11T14:09:21.676Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Android"><a href="#Android" class="headerlink" title="Android"></a>Android</h2><ol><li><p>View的绘制流程？</p><ul><li>的</li></ul></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Android&quot;&gt;&lt;a href=&quot;#Android&quot; class=&quot;headerlink&quot; title=&quot;Android&quot;&gt;&lt;/a&gt;Android&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;View的绘制流程？&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;的&lt;/li&gt;
&lt;/ul&gt;
&lt;/li
      
    
    </summary>
    
      <category term="Java、Android" scheme="http://yoursite.com/categories/Java%E3%80%81Android/"/>
    
    
      <category term="面试题" scheme="http://yoursite.com/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>Android中Context理解</title>
    <link href="http://yoursite.com/2018/08/21/Context%E6%A6%82%E8%BF%B0/"/>
    <id>http://yoursite.com/2018/08/21/Context概述/</id>
    <published>2018-08-20T16:00:00.000Z</published>
    <updated>2018-08-21T12:37:04.885Z</updated>
    
    <content type="html"><![CDATA[<p>Android中Context、Application与四大组件有什么联系<br><a id="more"></a></p><h2 id="Context概述"><a href="#Context概述" class="headerlink" title="Context概述"></a>Context概述</h2><p>context关系图如下：</p><p><div align="center"><br><img src="https://raw.githubusercontent.com/Tristan-Hou/MarkdownImg/master/res/Context%E5%85%B3%E7%B3%BB%E5%9B%BE.jpg" width="600" height="500"><br></div><br><em>图片取自网络</em></p><ol><li>Context是一个abstract类型，ContextImpl是实现类，实现了Context类型的核心功能；</li><li>ContextWrapper以及继承类都是一个包装器，最终功能都是通过impl类实现；</li><li><p>ContextWrapper构造函数会接收一个Context类型赋值给mBase：</p><pre><code>ContextWrapper(Context base){    mBase = base;}</code></pre></li></ol><h2 id="Context初始化"><a href="#Context初始化" class="headerlink" title="Context初始化"></a>Context初始化</h2><h3 id="Activity"><a href="#Activity" class="headerlink" title="Activity"></a>Activity</h3><ul><li>初始化流程： loadApk -&gt; ContextImpl -&gt; Application -&gt; attch()将impl赋给wrapper及子类</li></ul><ol><li><p>ActivityThread类中，performLaunchActivity():</p><pre><code>private Activity performLaunchActivity(ActivityClientRecord r, Intent customIntent) {    // 初始化 LoadedApk    if (r.packageInfo == null) {        r.packageInfo = getPackageInfo();    }    ...    // 创建 ContextImpl 实例    ContextImpl appContext = createBaseContextForActivity(r);    Activity activity = null;    try {        //反射，生成activity        java.lang.ClassLoader cl = appContext.getClassLoader();        activity = mInstrumentation.newActivity(                cl, component.getClassName(), r.intent);        ...    } catch (Exception e) {        ...    }    try {        //生成Application         Application app = r.packageInfo.makeApplication(false, mInstrumentation);         if(activity != null) {            ...             appContext.setOuterContext(activity);             ...             activity.attach(...);             ...         }     } catch (Exception e) {        ...    }    ...   return activity;}</code></pre></li><li><p>createBaseContextForActivity()创建ContextImpl实例:</p><pre><code>private ContextImpl createBaseContextForActivity(ActivityClientRecord r) {    final int displayId;    try {        displayId = ActivityManager.getService().getActivityDisplayId(r.token);    } catch (RemoteException e) {        throw e.rethrowFromSystemServer();    }    ContextImpl appContext = ContextImpl.createActivityContext(        this, r.packageInfo, r.activityInfo, r.token, displayId, r.overrideConfig);    ...    return appContext;}</code></pre><p>–</p><pre><code>static ContextImpl createActivityContext(ActivityThread mainThread,    LoadedApk packageInfo, ActivityInfo activityInfo, IBinder activityToken, int displayId,    Configuration overrideConfiguration) {    ...    ContextImpl context = new ContextImpl(null, mainThread, packageInfo, activityInfo.splitName,        activityToken, null, 0, classLoader);        ...    final ResourcesManager resourcesManager = ResourcesManager.getInstance();    context.setResources(resourcesManager.createBaseActivityResources(activityToken,        packageInfo.getResDir(),        splitDirs,        packageInfo.getOverlayDirs(),        packageInfo.getApplicationInfo().sharedLibraryFiles,        displayId,        overrideConfiguration,        compatInfo,        classLoader));    context.mDisplay = resourcesManager.getAdjustedDisplay(displayId,        context.getResources());    return context;}</code></pre></li><li><p>Activity.attach()为ContextWrapper.mBase赋值：</p><pre><code>final void attach() {    attachBaseContext(context);}protected void attachBaseContext() {    super.attachBaseContext(newBase);}ContextWrapper.attachBaseContext();</code></pre></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Android中Context、Application与四大组件有什么联系&lt;br&gt;
    
    </summary>
    
      <category term="Android" scheme="http://yoursite.com/categories/Android/"/>
    
    
      <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://yoursite.com/2018/04/20/back/"/>
    <id>http://yoursite.com/2018/04/20/back/</id>
    <published>2018-04-20T09:16:34.517Z</published>
    <updated>2018-04-20T09:16:34.517Z</updated>
    
    <content type="html"><![CDATA[<p>ext3 ：日志文件系统</p><p>ext4 ： 大文件系统</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;ext3 ：日志文件系统&lt;/p&gt;
&lt;p&gt;ext4 ： 大文件系统&lt;/p&gt;

      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>文件系统学习</title>
    <link href="http://yoursite.com/2018/04/01/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0/"/>
    <id>http://yoursite.com/2018/04/01/文件系统学习/</id>
    <published>2018-04-01T14:12:22.345Z</published>
    <updated>2018-04-19T04:35:14.253Z</updated>
    
    <content type="html"><![CDATA[<p>关于Linux文件系统的学习<br><a id="more"></a></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>关于Linux-Kernel学习的8个知识点</p><h3 id="地址"><a href="#地址" class="headerlink" title="地址"></a>地址</h3><ol><li>(CPU）物理地址 + （内核)虚拟地址 —— 地址转换</li><li>地址转换表：页表 —— 内存中，4K大小</li></ol><h3 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h3><p>管理内存地址，通过页表进行内存管理</p><h3 id="系统调用"><a href="#系统调用" class="headerlink" title="系统调用"></a>系统调用</h3><ol><li>Linux中的APi：用户态API、系统态API（内核）</li><li>用户态API通过调用系统调用来调用系统态API，隔离作用</li></ol><h3 id="线程调度"><a href="#线程调度" class="headerlink" title="线程调度"></a>线程调度</h3><p>多线程系统需要管理如何何时互相调用、切换等操作，便引入线程调度概念。线程调度方式有三种方式:</p><ol><li>时间段轮询</li><li>实时线程优先</li><li>线程优先等级</li></ol><h3 id="同步与线程通讯"><a href="#同步与线程通讯" class="headerlink" title="同步与线程通讯"></a>同步与线程通讯</h3><ol><li>同步线程通讯: 一个线程要求另一个线程完成某些任务，并且等待这个线程完成任务后，才继续执行;</li><li>异步线程通讯: 不要求另一个线程完成某些任务，也不会等待</li></ol><h3 id="中断"><a href="#中断" class="headerlink" title="中断"></a>中断</h3><p>硬件角度，外部电路的电平信号</p><h3 id="时钟与定时器管理"><a href="#时钟与定时器管理" class="headerlink" title="时钟与定时器管理"></a>时钟与定时器管理</h3><ol><li>硬件角度看，时钟是一种中断电路, 专用于系统时间，也叫系统心跳；</li><li>定时器是一种计数器</li></ol><h3 id="文件系统"><a href="#文件系统" class="headerlink" title="文件系统"></a>文件系统</h3><p>Linux为了更好的跨平台性，使用了虚拟文件系统，屏蔽了物理文件系统（Ext4、yaffs2等）的差异</p><h2 id="不同的文件系统"><a href="#不同的文件系统" class="headerlink" title="不同的文件系统"></a>不同的文件系统</h2><p>Linux启动时，第一个必须挂载的是根文件系统root；若系统不能从指定设备上挂载根文件系统，则系统会出错而退出启动。之后可以自动或手动挂载其他的文件系统。因此，一个系统中可以同时存在不同的文件系统。启动进程中文件系统的挂载是由 /etc/fstab 配置文件管理。</p><ol><li>基于FLASH的文件系统</li><li>基于RAM的文件系统</li><li>网络文件系统NFS (Network File System)</li></ol><p>Linux还支持逻辑的或伪文件系统(logical or pseudo file system)，例如procfs(proc文件系统)，用于获取系统信息，以及devfs(设备文件系统)和sysfs，用于维护设备文件。</p><div align="center"><br><img src="https://raw.githubusercontent.com/Tristan-Hou/MarkdownImg/master/res/fs%20root.png" width="500" height="600" align="center/"><br></div><p>粗体的目录组成了 root 文件系统的必需部分。也就是说，它们不能创建为一个分离的文件系统并且在开机时进行挂载。这是因为它们（特别是它们包含的内容）必须在系统启动的时候出现，从而系统才能正确启动。<br>非粗体的目录不需要在系统启动过程中出现，但会在之后挂载到 root 文件系统上，在开机阶段，它们为主机进行准备，从而执行有用的工作</p><h3 id="What’s-the-best-File-System-for-my-Linux-install"><a href="#What’s-the-best-File-System-for-my-Linux-install" class="headerlink" title="What’s the best File System for my Linux install?"></a>What’s the best File System for my Linux install?</h3><div align="center"><br><img src="https://raw.githubusercontent.com/Tristan-Hou/MarkdownImg/master/res/whats%20the%20best%20fs.jpg" width="500" height="250" align="center/"><br></div><ul><li>Ext4: Ext4 针对那些寻找超级可靠的基础环境或者那些只需要能工作就行的用户，几乎是所有 Linux 用户都会选择的文件系统;</li><li>BtrFs：B树(B-tree)文件系统，是当前其他文件系统的新一代替代者，目前其处于开发中。有很多面向高级用户的杀手级特性；</li><li>XFS：是一个高端文件系统，定位于速度和性能方面，并行IO出色。如果你有一台家庭服务器，而且你苦恼于如何部署存储环境，那么可以考虑下</li></ul><h2 id="文件系统体系结构"><a href="#文件系统体系结构" class="headerlink" title="文件系统体系结构"></a>文件系统体系结构</h2><ul><li>Linux的思想：<a href="https://opensource.com/life/15/9/everything-is-a-file" target="_blank" rel="noopener">一切都是文件</a>，包括硬件设备。这样，用户就可以用读写文件的方式实现对硬件的访问</li><li>若非文件，则为进程</li></ul><h3 id="什么是文件系统"><a href="#什么是文件系统" class="headerlink" title="什么是文件系统"></a>什么是文件系统</h3><ul><li>文件系统： 是对一个存储设备上的数据和元数据进行组织的机制</li><li><p>Linux文件系统实现为分层的体系结构，从而实现各个层级的的分离：</p><div align="center"><br><img src="https://raw.githubusercontent.com/Tristan-Hou/MarkdownImg/master/res/fs%20structure1.png" width="500" height="300" align="center/"><br></div></li></ul><div align="center"><br><img src="https://raw.githubusercontent.com/Tristan-Hou/MarkdownImg/master/res/fs%20structure2.png" width="500" height="300" align="center/"><br></div><ul><li>通过使用一组通用的API函数，Linux 可以在许多种存储设备上支持许多种文件系统：read 函数调用可以从指定的文件描述符读取一定数量的字节，它不了解文件系统的类型（ext4），也不了解文件系统所在的存储媒体（sata磁盘）</li></ul><h3 id="VFS层"><a href="#VFS层" class="headerlink" title="VFS层"></a>VFS层</h3><ol><li>底层文件系统的主要接口</li><li>用户态api通过系统调用调用内核态api，文件相关操作的系统回调函数，调用的就是VFS层的函数</li><li>每个文件系统实现（比如 ext2、JFS 等等）导出一组通用接口，供 VFS 使用</li><li>VFS提供的常用API：mount()、umount() … 、open()、close()… 、mkdir()</li><li>VFS记录当前支持的文件系统（命令：cat /proc/filesystems)以及当前挂载的文件系统（mount -l）</li></ol><h3 id="文件系统层"><a href="#文件系统层" class="headerlink" title="文件系统层"></a>文件系统层</h3><p>不同的文件系统实现了VFS的这些函数。文件系统把文件读写命令转化为对磁盘LBA的操作，起了一个翻译和磁盘管理的作用</p><h3 id="缓存层"><a href="#缓存层" class="headerlink" title="缓存层"></a>缓存层</h3><p>对磁盘LBA的读写数据缓存到这里，加速性能</p><h3 id="块设备层"><a href="#块设备层" class="headerlink" title="块设备层"></a>块设备层</h3><p>块设备接口Block Device是用来访问磁盘LBA的层级，读写命令组合之后插入到命令队列，磁盘的驱动从队列读命令执行</p><h3 id="磁盘驱动层"><a href="#磁盘驱动层" class="headerlink" title="磁盘驱动层"></a>磁盘驱动层</h3><p>磁盘的驱动程序把对LBA的读写命令转化为各自的协议</p><h3 id="磁盘物理层"><a href="#磁盘物理层" class="headerlink" title="磁盘物理层"></a>磁盘物理层</h3><h2 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h2><h3 id="物理磁盘到文件系统"><a href="#物理磁盘到文件系统" class="headerlink" title="物理磁盘到文件系统"></a>物理磁盘到文件系统</h3><ul><li>关于磁盘需要了解：</li></ul><ol><li>硬盘有数个盘片，每盘片两个面，每个面一个磁头</li><li>盘片被划分为多个扇形区域即扇区</li><li>同一盘片不同半径的同心圆为磁道</li><li>不同盘片相同半径构成的圆柱面即柱面</li><li>公式： 存储容量＝磁头数×磁道（柱面）数×每道扇区数×每扇区字节数</li><li>信息记录可表示为：××磁道（柱面），××磁头，××扇区</li></ol><ul><li>Linux如何管理这些空间——将磁盘块分为以下三个部分：</li></ul><ol><li>超级块：文件系统中第一个块被称为超级块。这个块存放文件系统本身的结构信息。比如，超级块记录了每个区域的大小，超级块也存放未被使用的磁盘块的信息</li><li>inode表：超级块下一部分就是inode表。每个inode对应一个文件/目录结构，包含了一个文件长度、创建/修改时间、权限、所属关系、磁盘中位置等信息。一个文件系统维护了一个索引节点的数组，每个文件或目录都与索引节点数组中的唯一一个元素对应。系统给每个索引节点分配了一个号码，也就是该节点在数组中的索引号，称为索引节点号</li><li>数据区：文件的内容保存在这个区域。磁盘上所有块的大小都一样。如果文件包含了超过一个块的内容，则文件内容会存放在多个磁盘块中</li></ol><ul><li>Linux正统的文件系统(如ext2、3等)将硬盘分区时会划分出目录块、inode Table区块和data block数据区域</li><li>一个文件由一个目录项、inode和数据区域块组成：</li></ul><ol><li>目录项:包括文件名和inode节点号。</li><li>inode包含文件的属性(如读写属性、owner等，以及指向数据块的指针)——inode里所包含的文件信息可以通过命令“stat filename”查看<div align="center"><br><img src="https://raw.githubusercontent.com/Tristan-Hou/MarkdownImg/master/res/inode.png" width="500" height="200" align="center/"><br></div></li><li>数据区域块则是文件内容</li></ol><ul><li>当查看某个文件时，会先从inode table中查出文件属性及数据存放点，再从数据块中读取数据<div align="center"><br><img src="https://raw.githubusercontent.com/Tristan-Hou/MarkdownImg/master/res/fs%20work.png" width="500" height="250" align="center/"><br></div></li></ul><p>或</p><div align="center"><br><img src="https://raw.githubusercontent.com/Tristan-Hou/MarkdownImg/master/res/inode2.png" width="500" height="250" align="center/"><br></div><h3 id="创建一个文件的过程"><a href="#创建一个文件的过程" class="headerlink" title="创建一个文件的过程"></a>创建一个文件的过程</h3><ul><li>命令行输入命令:who &gt; userlist</li><li>文件系统中增加了一个存放命令who输出内容的新文件userlist</li><li>文件主要有属性、内容以及文件名三项。内核将文件内容存放在数据区，文件属性存放在i-节点，文件名存放在目录中</li><li>创建成功一个文件主要有以下四个步骤:<ol><li>存储属性:也就是文件属性的存储，内核先找到一块空的i-节点。例如，内核找到i-节点号921130。内核把文件的信息记录其中。如文件的大小、文件所有者、和创建时间等</li><li>存储数据:即文件内容的存储，由于该文件需要3个数据块。因此内核从自由块的列表中找到3个自由块。如600、200、992，内核缓冲区的第一块数据复制到块600，第二和第三分别复制到922和600</li><li>记录分配情况:数据保存到了三个数据块中。所以必须要记录起来，以后再找到正确的数据。分配情况记录在文件的i-节点中的磁盘序号列表里。这3个编号分别放在最开始的3个位置</li><li>添加文件名到目录:新文件的名字是userlist 内核将文件的入口(47,userlist)添加到目录文件里。文件名和i-节点号之间的对应关系将文件名和文件和文件的内容属性连接起来，找到文件名就找到文件的i-节点号，通过i-节点号就能找到文件的属性和内容</li></ol></li></ul><h3 id="创建一个目录的过程"><a href="#创建一个目录的过程" class="headerlink" title="创建一个目录的过程"></a>创建一个目录的过程</h3><ul><li>mkdir创建目录</li><li>目录也是文件</li><li>创建过程和文件创建过程一样，只是第二步写的内容不同<ol><li>系统找到空闲的i-节点号887220,写入目录的属性</li><li>找到空闲的数据块1002来存储目录的内容，只是目录的内容比较特殊，包含文件名字列表，列表一般包含两个部分：i-节点号和文件名，这个列表其实也就是文件的入口，新建的目录至少包含三个目录”.”和”..”其中”.”指向自己，”..”指向上级目录，我们可以通过比较对应的i-节点号来验证,887270 对应着上级目录中的child对应的i-节点号</li><li>记录分配情况。这个和创建文件完全一样</li><li>添加目录的入口到父目录，即在父目录中的child入口</li></ol></li><li>一般都说文件存放在某个目录中，其实目录中存入的只是文件在i-节点表的入口，而文件的内容则存储在数据区。我们一般会说“文件userlist在目录test中”,其实这意味着目录test中有一个指向i-节点921130的链接，这个链接所附加的文件名为userlist,这也可以这样理解：目录包含的是文件的引用，每个引用被称为链接。文件的内容存储在数据块。文件的属性被记录在一个被称为i-节点的结构中。i-节点的编号和文件名关联起来存在目录中。</li></ul><h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><ul><li>文件都有文件名与数据，Linux上分成两个部分：用户数据 (user data) 与元数据 (metadata)</li><li>元数据中的 inode 号，是文件的唯一标识而非文件名。文件名仅是为了方便人们的记忆和使用，系统或程序通过 inode 号寻找正确的文件数据块</li></ul><h4 id="硬链接创建过程"><a href="#硬链接创建过程" class="headerlink" title="硬链接创建过程"></a>硬链接创建过程</h4><ul><li>若一个 inode 号对应多个文件名，则称这些文件为硬链接</li><li>硬链接就是同一个文件使用了多个别名，可由命令link或ln创建</li><li>硬链接特点：<ol><li>文件有相同的 inode 及 data block</li><li>只能对已存在的文件进行创建</li><li>不能交叉文件系统进行硬链接的创建，不能跨文件系统</li><li>不能对目录进行创建，只可对文件创建</li><li>删除一个硬链接文件并不影响其他有相同 inode 号的文件</li></ol></li><li>创建过程：<ol><li>通过原文件的文件名找到文件的i-节点号</li><li>添加文件名关联到目录，新文件的名字是mylink 内核将文件的入口(921130,mylink)添加到目录文件里——不需要写文件内容，仅仅关联文件名至目录，源文件连接数+1</li></ol></li></ul><h4 id="软链接创建过程"><a href="#软链接创建过程" class="headerlink" title="软链接创建过程"></a>软链接创建过程</h4><ul><li>软连接与windows下的快捷方式类似</li><li>若文件用户数据块中存放的内容是另一文件的路径名的指向，则该文件就是软连接</li></ul><h3 id="挂载"><a href="#挂载" class="headerlink" title="挂载"></a>挂载</h3><p>将一个文件系统与一个存储设备关联起来的过程称为挂装（mount）。</p><ul><li>文件系统中挂载文件系统：</li></ul><ol><li>dd 命令创建一个指定大小的文件：dd if=/dev/zero of=file.img bs=1k count=10000  —— 10MB大小</li><li>losetup 命令将一个循环设备与这个文件关联起来，让它看起来像一个块设备，而不是文件系统中的常规文件： losetup /dev/loop0 file.img  —— /dev/loop0表示file.img作为块设备</li><li>mke2fs创建一个指定大小的新的 ext2 文件系统： mke2fs -c /dev/loop0 10000</li><li>使用 mount 命令将循环设备（/dev/loop0）所表示的 file.img 文件挂载到挂载点 /mnt/point1： <ul><li>mkdir /mnt/point1</li><li>mount -t ext2 /dev/loop0 /mnt/point1</li><li>ls /mnt/point1</li></ul></li><li>还可以在这个文件系统中再次建立文件系统<ul><li>d if=/dev/zero of=/mnt/point1/file.img bs=1k count=1000</li><li>losetup /dev/loop1 /mnt/point1/file.img</li><li>mke2fs -c /dev/loop1 1000</li><li>mkdir /mnt/point2</li><li>mount -t ext2 /dev/loop1 /mnt/point2</li><li>ls /mnt/point2</li><li>ls /mnt/point1</li></ul></li></ol><h3 id="文件的拷贝、剪切的底层过程"><a href="#文件的拷贝、剪切的底层过程" class="headerlink" title="文件的拷贝、剪切的底层过程"></a>文件的拷贝、剪切的底层过程</h3><ol><li>拷贝文件：创建一个新的inode节点，并且拷贝数据块内容: <ul><li>stat A</li><li>cp A D</li><li>stat D</li></ul></li><li><p>剪切文件：同个分区里边mv，inode节点不变，只是更新目录文件对应数据块里边的文件名和inode对应关系</p><ul><li>stat D</li><li>mv D F</li><li>stat F</li></ul><p>跨分区mv，则跟拷贝一个道理，需要创建新的inode，因为inode节点不同分区是不能共享的</p><ul><li>mv F /data/F</li><li>stat /data/F</li></ul></li></ol><h3 id="软连接和硬连接过程"><a href="#软连接和硬连接过程" class="headerlink" title="软连接和硬连接过程"></a>软连接和硬连接过程</h3><ol><li>创建软连接会创建一个新的inode节点，其对应数据块内容存储所链接的文件名信息，这样原文件即便删除了，重新建立一个同名的文件，软连接依然能够生效<ul><li>touch A</li><li>stat A</li><li>ln -s A B</li><li>stat A</li><li>stat B</li></ul></li></ol><p>可对不存在的文件创建软链接</p><ul><li>ln -s old.file soft.link</li><li>ls -liF </li></ul><p>由于被指向的文件不存在，此时的软链接 soft.link 就是死链接</p><ul><li>cat soft.link</li></ul><p>创建被指向的文件 old.file，soft.link 恢复成正常的软链接</p><ul><li>echo “This is an original file_A” &gt;&gt; old.file</li><li>cat soft.link </li></ul><ol><li><p>创建硬链接，并不会新建inode节点，只是links加1，还有再目录文件对应数据块上增加一条文件名和inode对应关系记录；只有将硬链接和原文件都删除之后，文件才会真正删除，即links为0才真正删除</p><ul><li>stat A</li><li>ln A C</li><li>stat A</li><li>stat C</li></ul><p>文件有相同的 inode 号以及 data block</p><ul><li>不能交叉文件系统 ln /dev/input/event5 /root/bfile.txt</li><li>不能对目录进行创建硬连接：1. mkdir -p old.dir/test   2. ln old.dir/ hardlink.dir</li></ul></li></ol><h3 id="Linux统一目录结构"><a href="#Linux统一目录结构" class="headerlink" title="Linux统一目录结构"></a>Linux统一目录结构</h3><ol><li>特点：<ul><li>只有一棵目录树来搜索文件和程序</li><li>因为只有一个文件系统，所以 /home、/tmp、/var、/opt 或 /usr 能够创建在和 root（/）文件系统不同的物理硬盘驱动器、分区或逻辑分区上，然后挂载到一个挂载点（目录）上，从而作为 root 文件系统树的一部分。甚至可移动驱动器，比如 USB 驱动器或一个外接的 USB 或 ESATA 硬盘驱动器均可以挂载到 root 文件系统上，成为目录树不可或缺的部分</li></ul></li><li>优点：灵活<ul><li>Linux 发行版升级过程中偶尔重新格式化包含操作系统的硬盘驱动来删除那些长期积累的垃圾，如果 /home 目录是 root 文件系统的一部分（位于同一个硬盘驱动器），那么它也会被格式化，然后需要通过之前的备份恢复。如果 /home 目录作为一个分离的文件系统，那么安装程序将会识别到，并跳过它的格式化。对于存储数据库、邮箱、网页和其它可变的用户以及系统数据的 /var 目录也是这样的</li><li>将 Linux 系统目录树的某些部分作为一个分离的文件系统还有一些其他原因。比如，在很久以前，我还不知道将所有需要的 Linux 目录均作为 root（/）文件系统的一部分可能存在的问题，于是，一些非常大的文件填满了 /home 目录。因为 /home 目录和 /tmp 目录均不是分离的文件系统，而是 root 文件系统的简单子目录，整个 root 文件系统就被填满了。于是就不再有剩余空间可以让操作系统用来存储临时文件或扩展已存在数据文件。首先，应用程序开始抱怨没有空间来保存文件，然后，操作系统也开始异常行动。启动到单用户模式，并清除了 /home 目录中的多余文件之后，终于又能够重新工作了。然后，我使用非常标准的多重文件系统设置来重新安装 Linux 系统，从而避免了系统崩溃的再次发生。</li><li>我曾经遇到一个情况，Linux 主机还在运行，但是却不允许用户通过 GUI 桌面登录。我可以通过使用虚拟控制台之一，通过命令行界面（CLI）本地登录，然后远程使用 SSH 。问题的原因是因为 /tmp 文件系统满了，因此 GUI 桌面登录时所需要的一些临时文件不能被创建。因为命令行界面登录不需要在 /tmp目录中创建文件，所以无可用空间并不会阻止我使用命令行界面来登录。在这种情况下，/tmp 目录是一个分离的文件系统，在 /tmp 所位于的逻辑卷上还有大量的可用空间。我简单地扩展了 /tmp 逻辑卷的容量到能够容纳主机所需要的临时文件，于是问题便解决了。注意，这个解决方法不需要重启，当 /tmp 文件系统扩大以后，用户就可以登录到桌面了。</li><li>当我在一家很大的科技公司当实验室管理员的时候，遇到过另外一个故障。开发者将一个应用程序安装到了一个错误的位置（/var）。结果该应用程序崩溃了，因为 /var 文件系统满了，由于缺乏空间，存储于 /var/log 中的日志文件无法附加新的日志消息。然而，系统仍然在运行，因为 root 文件系统和 /tmp 文件系统还没有被填满。删除了该应用程序并重新安装在 /opt 文件系统后，问题便解决了。</li></ul></li></ol><hr><p><a href="https://blog.csdn.net/wanghaofeng/article/details/5720235" target="_blank" rel="noopener">操作系统课程设计–简单文件系统的实现</a> : 时间关系，未读。。。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;关于Linux文件系统的学习&lt;br&gt;
    
    </summary>
    
      <category term="Linux" scheme="http://yoursite.com/categories/Linux/"/>
    
    
      <category term="Linux" scheme="http://yoursite.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>ffmpeg函数</title>
    <link href="http://yoursite.com/2018/02/27/ffmpeg%E5%87%BD%E6%95%B0/"/>
    <id>http://yoursite.com/2018/02/27/ffmpeg函数/</id>
    <published>2018-02-27T08:35:50.400Z</published>
    <updated>2018-03-27T07:16:36.286Z</updated>
    
    <content type="html"><![CDATA[<p>摘自雷晓华大神博客<a href="http://blog.csdn.net/leixiaohua1020/article/details/11979565" target="_blank" rel="noopener">ffmpeg函数介绍</a></p><p>学习和使用ffmpeg，必须了解这些函数。<br><a id="more"></a></p><h3 id="libavcodec"><a href="#libavcodec" class="headerlink" title="libavcodec"></a>libavcodec</h3><ol><li>avcodec_init():<ul><li>初始化libavcodec，一般最先调用，在程序启动或模块初始化时调用，多次调用无效</li><li>#include “libavcodec/avcodec.h”</li><li>实现在：\ffmpeg\libavcodec\utils.c</li><li>非线程安全</li></ul></li></ol><h3 id="libavformat"><a href="#libavformat" class="headerlink" title="libavformat"></a>libavformat</h3><ol><li><p>av_register_all():</p><ul><li>初始化libavformat和注册所有mexers、demuxers和protocols</li><li>一般在avcodec_init()后调用</li><li>#include “libavformat/avformat.h”</li><li>实现在: \ffmprg\libavformat\allformat.c</li><li>其中会调用avcodec_register_all()注册多种音视频格式的编解码器，并且注册各种文件的编解复用器</li><li>If you do not call this function, then you can select exactly which formats you want to support.</li><li>av_register_input_format()/av_register_output_format()/av_register_protocol()</li></ul></li><li><p>avformat_alloc_context():</p><ul><li>分配一个<a href="#avformatcontext">AVFormatContext</a>结构，并初始化</li><li>avformat_free_context()释放该结构里左右的东西以及该结构本身</li><li>#include “libavformat/avformat.h”</li><li>是现在：\ffmpeg\libavformat\options.c</li><li>某些版本中函数名是：av_alloc_format_context()</li></ul></li><li><p>avformat_free_context():</p><ul><li>释放一个AVFormatContext结构</li><li>#include “libavformat/avformat.h”</li><li>实现在：\ffmpeg\libavformat\utils.c</li><li>除了释放AVFormatContext结构本身外，AVFormatContext中指针所指向的内存也会一并释放</li><li>某些版本中函数名是：av_free_format_context()</li></ul></li><li><p><span id="avformatcontext">AVFormatContext</span>结构</p><ul><li>是FFMpeg里关于输入、输出相关信息的一个容器</li><li><p>#include “libavformat/avformat.h”</p><pre><code>typedef struct AVFormatContext {    struct AVInputFormat *iformat;    struct AVOutputFormat *oformat;    AVIOContext *pb;    unsigned int nb_streams;    AVStream **streams;    char filename[1024];    ...} AVFormatContext;</code></pre></li><li><p>作为输入容器时 struct AVInputFormat *iformat 不能为空，其中包含了输入文件的音视频流信息，程序从输入容器读出音视频包进行解码处理</p></li><li>作为输出容器时 struct AVOutputFormat *oformat 不能为空，程序把编码好的音视频包写入到输出容器中</li><li><a href="#aviocontext">AVIOContext</a> *pd I/O上下文，通过对该变量赋值可以改变输入源或输出目的</li><li>unsigned int nb_streams 音视频流数量</li><li>AVStream **streams 音视频流</li></ul></li><li><p><span id="aviocontext">AVIOContext</span></p><pre><code>typedef struct {    unsigned char *buffer; //start of buffer    int buffer_size; //maxinum buffer size    unsighed char *buf_ptr; //current position in the buffer    unsighed char *buf_end; /* end of the data, may be less than                                buffer + buffer_size if the read                                function returned less data than                                requested, e.g. for streams where                                no more data has been received                                yet.*/    void *opaque; //private pointer, passed to the read/write/seek/... function    int (*read_packet)(void *opaque, uint8_t *buf, int buf_size);    int (*write_packet)(void *opaque, uint8_t *buf, int buf_size);    int64_t(*seek)(void *opaque, int64_t offset, int whence);    int64_t pos; //position in the file of the current buffer    int must_flush; //true if the next seek should flush    int eof_reached; //true if eof reached    int write_flag; //true if open for writing    #if FF_API_OLD_AVIO        attribute_deprecated int is_streamed;    #endif    int max_packet_size;    unsigned long checksum;    unsigned char *checksum_ptr;    unsigned long (*update_checksum)(unsigned long checksum, const uint8_t *buf, unsigned int size):    int error; //contains the error code or 0 if no error happened.    /* Pause or resume palyback for network streaming protocols */    int (*read_pause)(void *opaque, int pause);    /* seek to a given timeStamp in stream with the specified     stream_index. Needed for some network streaming protocols      which don&apos;t support seeking to byte position. */    int64_t (*read_seek)(void *opaque, int stream_index, int64_t timestamp, int flags);    /* A combination of AVIO_SEEKABLE_ flag or 0 when the     stream is not seekable.*/    int seekable;} AVIOContext;</code></pre><ul><li>字节流I/O上下文</li><li>在结构的尾部增加变量可以减少版本冲突</li><li>移除、排序、修改已经存在的变量将会导致较大版本的冲突</li><li>sizeof(AVIOContext)在libav*.外部不可使用</li><li>AVIOContext里的函数指针不能直接使用，通常使用avio_alloc_context()函数来设置其中的函数指针</li><li>unsigned char *buffer; 缓存的起始指针</li><li>int buffer_size；缓存的最大值</li><li>void *opaque；回调中使用的指针</li><li>int (<em>read_packet)(void \</em>opaque, uint8_t *buf, int buf_size); 读文件回调方法</li><li>int (<em>write_packet)(void \</em>opaque, uint8_t *buf, int buf_size); 写文件毁掉方法</li><li>int64_t (<em>seek)(void \</em>opaque, uint64_t offset, int shence); seek文件回调方法</li></ul></li><li><p>avio_alloc_context()</p><pre><code>/* Allocate and initialize an AVIOContext for buffered I/O. It must be later freed with av_free().@param buffer Memory block for input/output operations via AVIOContext. The buffer ust be allocated whit av_malloc() andfriends.@param buffer_size The buffer size is very important for performance.For protocols with fixed blocksize it should be set to this blocksize.For others a typical size is a cache page, e.g. 4kb.@param write_flag Set to 1 if the buffer should be writable, 0 otherwise.@param opaque An opaque pointer to user-specific data.@param read_packet A function for refilling the buffer, may be NULL@param write_packet A function for writing the buffer contents, maybe NULL.@param seek A function for seeking to specified byte position, may be NULL.@return Allocated AVIOContext or NULL on failure. */AVIOContext *avio_alloc_context(unsigned char *buffer,     int buffer_size, int write_flag, void *opaque,    int (*read_packet)(void *opaque, uint8_t *buf, int buf_size),    int (*write_packet)(void *opaque, uint8_t *buf, int buf_size),    int64_t (*seek)(void *opaque, int64_t offset, int whence));</code></pre><ul><li>为I/O缓存申请并初始化一个AVIOContext结构，结束时必须使用av_free()释放</li><li>unsigned char *buffer 输入/输出缓存内存块，必须是使用av_malloc()分配的</li><li>int buffer_size 缓存大小很重要</li><li>int write_flag 缓存为可写则设置为1，否则0</li><li>void *opaque 指针，回调时使用</li></ul></li><li><p>av_open_input_file()</p><pre><code>attribute_deprecated int av_open_input_file(    AVFormatContext **ic_ptr, const char *filename,     AVInputFormat *fmt, int buf_size, AVFormatParameters *ap);</code></pre><ul><li>输入方式打开一个媒体文件，codecs并没有打开，只读取文件头信息；</li><li>头文件：#include “libavformat/avformat.h”</li><li>AVFormatContext **ic_ptr 输入文件容器</li><li>const char *filename 输入文件名，全路径，要保证文件存在</li><li>AVInputFormat *fmt 输入文件格式，可以为NULL</li><li>int buf_size 缓冲区大小，可为0</li><li>AVFormatParameters *ap 格式参数，可为NULL</li><li>成功返回0，其他失败</li><li>不赞成使用avformat_open_input</li></ul></li><li><p>av_close_input_file()</p><pre><code>void av_close_input_file(AVFormatContext *s)</code></pre><ul><li>关闭使用avformat_close_input()打开的输入文件容器，但并不关闭它的codecs</li><li>#include “libavformat/avformat.h”</li><li>使用av_open_input_file打开的文件容器，使用该函数关闭</li><li>使用av_close_input_file关闭后，就不再需要avformat_free_context释放了</li></ul></li><li><p>av_find_stream_inof()</p><pre><code>int av_find_stream_info(AVFormatContext *ic)</code></pre><p>- </p></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;摘自雷晓华大神博客&lt;a href=&quot;http://blog.csdn.net/leixiaohua1020/article/details/11979565&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;ffmpeg函数介绍&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;学习和使用ffmpeg，必须了解这些函数。&lt;br&gt;
    
    </summary>
    
      <category term="ffmpeg" scheme="http://yoursite.com/categories/ffmpeg/"/>
    
    
      <category term="ffmpeg" scheme="http://yoursite.com/tags/ffmpeg/"/>
    
  </entry>
  
  <entry>
    <title>Java类加载器</title>
    <link href="http://yoursite.com/2018/01/14/Java%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8/"/>
    <id>http://yoursite.com/2018/01/14/Java类加载器/</id>
    <published>2018-01-14T15:20:40.609Z</published>
    <updated>2018-01-19T07:06:15.987Z</updated>
    
    <content type="html"><![CDATA[<p>类的数据从class文件加载到内存，并对数据进行<code>校验</code>、<code>解析</code>和<code>初始化</code>，形成可以被虚拟机直接使用的java类型，这就是类加载机制<br><a id="more"></a><br>加载、链接、初始化都在运行期完成，增加了一些内存开销，但是提高了灵活性（面向接口编程，运行时才指定其实际的实现类；本地应用程序从网络流加载一个二进制流程序代码运行）</p><h2 id="类加载时机"><a href="#类加载时机" class="headerlink" title="类加载时机"></a>类加载时机</h2><p>生命周期：</p><div align="center"><br>    <img src="https://raw.githubusercontent.com/Tristan-Hou/MarkdownImg/master/res/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.jpg" width="500" height="200" alt="" align="center"><br></div><p>加载-验证-准备-解析-初始化-使用-卸载，其中验证-准备-解析统称为连接。</p><p>初始化：以下5条被称为类主动引用，会触发初始化（其他任何方式引用类都不会初始化）</p><ul><li>使用new、读取或设置一个累的静态字段、调用一个类静态方法时，会生成<code>new</code>、<code>getstatic</code>、<code>putstatic</code>、<code>invokestatic</code>这四条字节码指令 </li><li>反射</li><li>初始化一个类，先初始化其父类</li><li>虚拟机启动时，会先初始化执行包含<code>main()</code>的那个类</li><li><p>jdk 1.7 动态语言支持，如果java.lang.invoke.MethodHandle实例最后解析结果REF_getstatic、REF_putstatic、REF_invokestatic方法句柄，并且这个方法句柄对应的类没有进行过初始化，需先触发初始化</p><pre><code>//被动使用：子类引用父类静态字段，不会初始化子类public class SuperClass {    static {        System.out.println(&quot;SuperClass init!&quot;);    }    public static int value = 123;}public class SubClass extends SuperClass {    static {        System.out.println(&quot;SubClass init!&quot;);    }}public class NotInitialization {    public static void main(String[] args) {        System.out.println(SubClass.value);    }}//-----------------------------------------------// SuperClass init!</code></pre><p>  静态字段，只有直接定义这个字段的类才会被初始化。</p><pre><code>public class  NotInitialization {    public static void main(String[] args) {        SuperClass[] sca = new SuperClass[10];    }}//-----------------------------------------------// no output.</code></pre><p>  但其实虚拟机为我们创建了一个数组对象[LxxxxSuperClass，并初始化  </p><pre><code>public class ConstClass {    static {        System.out.println(&quot;ConstClass init!&quot;);    }    public static final String HELLOWORLD = &quot;hello world&quot;;}public class  NotInitialization {    public static void main(String[] args) {        System.out.println(ConstClass. HELLOWORLD);    }}//-----------------------------------------------// hello world</code></pre><p> 常量在编译阶段会存入调用累的常量池里。</p></li></ul><h2 id="类加载过程"><a href="#类加载过程" class="headerlink" title="类加载过程"></a>类加载过程</h2><h3 id="加载"><a href="#加载" class="headerlink" title="加载"></a>加载</h3><ol><li>加载阶段，虚拟机需要完成3件事：<ul><li>通过一个类的全限定名来获取定义此类的二进制字节流<ul><li>从zip包读取——JAR、EAR、WAR格式基础</li><li>网络中获取——Applet</li><li>运行时计算生成——动态代理技术，java.lang.reflect.Proxy</li><li>其他文件生成——JSP（JSP文件生成对应的CLass类）</li><li>数据库读取</li></ul></li><li>将这个字节流所代表的静态存储结构转化为方法区运行时数据结构<ul><li>将对象类型信息存储在方法区</li><li>类全限定名</li><li>当前类直接弗雷全限定名</li><li>这个类的接口类型、类类型、枚举类型</li><li>类的访问修饰符信息</li><li>当前类型的超接口全限定名</li><li>当前类型的常量池</li><li>字段信息</li><li>方法信息</li><li>根据以上信息可以创建对象</li></ul></li><li>内存生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口</li></ul></li><li>非数组类可以使用自定义、系统的加载器加载；数组类本身不通过类加载器加载，由虚拟机直接创建</li></ol><h3 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h3><p>连接阶段第一步，确保class文件中字节流包含的信息符合当前虚拟机要求（任何途径都可以生成class文件，并不一定要求用java编译，因此其他语言可能会做到某些java语言做不到的事情，危害虚拟机系统安全）。验证阶段主要完成：</p><ul><li>文件格式验证：字节流符合class文件规范<ul><li>是否以魔数0xCAFFBABE开头</li><li>主、次版本号是否在当前虚拟机处理范围内</li><li>常量池始终是否有不支持类型</li><li>……</li></ul></li><li>元数据验证：对字节码描述的信息进行语义分析，以保证其描述的信息符合Java语言规范的要求<ul><li>是否有父类（除了java.lang.Object，所有类都有父类）</li><li>父类是否继承了不允许继承的类（final修饰）</li><li>是否实现了父类或接口的抽象方法</li><li>类中字段、方法是否与父类冲突矛盾（覆盖父类final字段、重载了方法，但返回值类型不同等）</li></ul></li><li>字节码验证：通过数据流和控制流分析，确定程序语义是合法的、符合逻辑的，主要对类的方法体进行校验分析<ul><li>确保任意时刻操作数栈数据类型与指令代码序列配合工作，不会出现类似操作数栈放了int类型数据，却在使用时按long类型加载</li><li>跳转指令不会跳出方法体外的字节码指令上</li><li>类型转换有效——子类转父类，父类转子类非法等</li></ul></li><li>引用符号验证：确保解析动作能正确执行<ul><li>符号引用中通过字符串描述的全限定名是否能找到对应的类</li><li>指定类中是否存在符合方法的字段描述符以及简单名称所描述的方法和字段</li><li>符号引用中的类、字段、方法的访问性是否可被当前类访问</li></ul></li></ul><h3 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h3><p>准备阶段是为类变量分配内存并设置类变量初始值的阶段，这些变量所使用的内存都将在方法区中进行分配。</p><ol><li>这时候进行的内存分配仅包括类变量（static变量），不包括实例变量，实例变量将会在对象实例化时随着对象一起分配在堆中。</li><li><p>这里的初始值<code>通常情况</code>是数据类型的零值：</p><pre><code>public static int value = 123;</code></pre><p>value在准备阶段过后初始值为0，而不是123。此时尚未开始执行任何java方法，只有在初始化阶段，执行虚拟机为static构造的<code>&lt;clinit&gt;()</code>方法后，通过指令<code>putstatic</code>将123赋值给value</p></li><li><p>有“通常情况”，就有<code>特殊情况</code>。如果类字段的字段属性表中存在ConstantValue属性，那么在准备阶段value就会被初始化为指定值：</p><pre><code>public static final int value = 123;</code></pre><p>由于final的修饰，class文件中value会带有ConstantValue属性。</p></li></ol><h3 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h3><p>解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程。解析动作主要针对类或接口、字段、类方法、接口方法、方法类型、方法句柄和调用点限定符7类符号引用进行。</p><ul><li>符号引用：一组符合描述所引用的目标，只要使用时无歧义的定位到目标，可以是任何形式的字面量。引用的目标并不一定已经加载到内存中。</li><li>直接引用：直接指向目标的指针、相对偏移量或一个能简介定位到目标的句柄。如果有了直接引用，那么引用目标一定已经在内存在存在</li></ul><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p>到了初始化阶段，才真正开始执行类中定义的java程序代码。执行类构造器<clinit>()方法，初始化类变量和其他资源。</clinit></p><ol><li><p>\<clinit>()方法是由编译器自动收集类中的所有类变量的赋值动作和静态语句块static{}中的语句合并产生的，编译器收集的顺序是由语句在源文件中出现的顺序所决定的，静态语句块只能访问到定义在静态语句块之前的变量，定义在它之后的变量，在前面的静态语句块可以赋值，但是不能访问。</clinit></p><pre><code>public class Test {    static {        i=0;        System.out.println(i);//这句编译器会报错：Cannot reference a field before it is defined（非法向前应用）    }    static int i=1;}</code></pre></li><li><p>虚拟机会自动保证优先调用父类的\<clinit>()方法，因此弗雷中的静态语句块优先于子类的变量赋值操作</clinit></p><pre><code>static class Parent {    public static int A =1;    static {        A = 2;    }}static class Sub extends Parent {    public static int B = A;}public static void main(String[] args) {    System.out.println(Sub.B);}//-------------------------------------------// 2</code></pre></li><li><p>接口的\<clinit>()不需要先执行父类的\<clinit>()方法，只有当父接口中定义的变量使用时，父接口才会初始化。接口的实现类在初始化时也一样不会执行接口的\<clinit>()</clinit></clinit></clinit></p></li><li><p>虚拟机会保证一个类的\<clinit>()方法在多线程环境中被正确的加锁、同步，如果多个线程同时去初始化一个类，那么只会有一个线程去执行这个类的\<clinit>()方法，其他线程都需要阻塞等待，直到活动线程执行\<clinit>()方法完毕。如果在一个类的\<clinit>()方法中有好事很长的操作，就可能造成多个线程阻塞，在实际应用中这种阻塞往往是隐藏的</clinit></clinit></clinit></clinit></p><pre><code>package jvm.classload;public class DealLoopTest{    static class DeadLoopClass{        static{               if(true){                   System.out.println(Thread.currentThread()+&quot;init DeadLoopClass&quot;);               while(true){}        }    }    public static void main(String[] args){        Runnable script = new Runnable(){           public void run(){              System.out.println(Thread.currentThread()+&quot; start&quot;);              DeadLoopClass dlc = new DeadLoopClass();              System.out.println(Thread.currentThread()+&quot; run over&quot;);          }       };       Thread thread1 = new Thread(script);       Thread thread2 = new Thread(script);       thread1.start();       thread2.start();     }}//-----------------------------------------------//Thread[Thread-0,5,main] start//Thread[Thread-1,5,main] start//Thread[Thread-0,5,main]init DeadLoopClass</code></pre><p> 需要注意的是，其他线程虽然会被阻塞，但如果执行\<clinit>()方法的那条线程退出\<clinit>()方法后，其他线程唤醒之后不会再次进入\<clinit>()方法。同一个类加载器下，一个类型只会初始化一次。</clinit></clinit></clinit></p><pre><code>static{    System.out.println(Thread.currentThread() + &quot;init DeadLoopClass&quot;);    try{        TimeUnit.SECONDS.sleep(10);    }catch (InterruptedException e){        e.printStackTrace();    }}//---------------------------------------------//Thread[Thread-0,5,main] start//Thread[Thread-1,5,main] start//Thread[Thread-1,5,main]init DeadLoopClass (之后sleep 10s)//Thread[Thread-1,5,main] run over//Thread[Thread-0,5,main] run over</code></pre></li></ol><h2 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h2><h3 id="类与类加载器"><a href="#类与类加载器" class="headerlink" title="类与类加载器"></a>类与类加载器</h3><p>只有在两个类是由同一个类加载器加载的前提下，才有意义；否则，即使两个类来源于同一个class文件，被同一个虚拟机加载，只要加载它们的类加载器不同，就一定不相等（equals()/isInstance()等）</p><h3 id="双亲委派模型"><a href="#双亲委派模型" class="headerlink" title="双亲委派模型"></a>双亲委派模型</h3><ol><li>三种类加载器：启动类加载器、扩展类加载器、应用程序类加载器</li><li>类加载器先将加载请求委派给父类加载器，只有父类加载器反馈自己无法完成加载请求，才由子类加载器加载</li></ol><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><ul><li><p>一道练习题：</p><pre><code>package jvm.classload;public class StaticTest{    public static void main(String[] args){        staticFunction();    }    static StaticTest st = new StaticTest();    static{        System.out.println(&quot;1&quot;);    }    {        System.out.println(&quot;2&quot;);    }    StaticTest(){        System.out.println(&quot;3&quot;);        System.out.println(&quot;a=&quot;+a+&quot;,b=&quot;+b);    }    public static void staticFunction(){        System.out.println(&quot;4&quot;);    }    int a=110;    static int b =112;}</code></pre></li><li><p>输出是多少？？？</p></li><li><p>先看一个简化代码：</p><pre><code>public class Test {    public static void main(String[] args) {        func();    }    static Test st = new Test();    static void func(){}}  </code></pre><ul><li>main调用，触发静态初始化</li><li>初始化Test静态部分，遇到st成员</li><li>st引用的是本类的实例</li><li>开始实例化st变量（实例初始化嵌入到静态初始化流程中）</li><li>st实例化之后，完成静态初始化剩下的工作</li><li>看起来像是<code>实例初始化出现在了静态初始化之前</code></li></ul></li><li><p>答案：</p><pre><code>23a=110,b=014</code></pre></li><li>why：<ul><li>准备阶段，st=null，b=0；</li><li>初始化阶段：执行构造器。限制性第一条静态语句 st = new StaticTest()，此后进行对象初始化，先初始化成员变量，再执行构造方法。因此，a赋值110，打印2，执行构造方法，打印3，a=110,b=0</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;类的数据从class文件加载到内存，并对数据进行&lt;code&gt;校验&lt;/code&gt;、&lt;code&gt;解析&lt;/code&gt;和&lt;code&gt;初始化&lt;/code&gt;，形成可以被虚拟机直接使用的java类型，这就是类加载机制&lt;br&gt;
    
    </summary>
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
      <category term="Class Loader" scheme="http://yoursite.com/tags/Class-Loader/"/>
    
  </entry>
  
  <entry>
    <title>dex文件结构</title>
    <link href="http://yoursite.com/2018/01/14/dex%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/"/>
    <id>http://yoursite.com/2018/01/14/dex文件结构/</id>
    <published>2018-01-14T11:00:34.208Z</published>
    <updated>2018-01-14T12:22:35.193Z</updated>
    
    <content type="html"><![CDATA[<p>本文主要记录Android中dex文件的结构。</p><a id="more"></a><h2 id="Dex类文件结构"><a href="#Dex类文件结构" class="headerlink" title="Dex类文件结构"></a>Dex类文件结构</h2><h3 id="Dex文件数据项"><a href="#Dex文件数据项" class="headerlink" title="Dex文件数据项"></a>Dex文件数据项</h3><table><thead><tr><th>类型</th><th>含义</th></tr></thead><tbody><tr><td>U1</td><td>等同于uint8_t，1字节</td></tr><tr><td>U2</td><td>unint16_t，2字节</td></tr><tr><td>U4</td><td>uint32_t，4字节</td></tr><tr><td>U8</td><td>uint64_t，8字节</td></tr><tr><td>sleb128</td><td>有符号LEB128，可变长度1~5字节</td></tr><tr><td>uleb128</td><td>无符号LEB128，可变长度1~5字节</td></tr><tr><td>uleb128p1</td><td>无符号LEB128+1，可变长度1~5字节</td></tr></tbody></table><p>leb128:</p><table cellspacing="3px"><br>    <tr><br>        <td colspan="16" align="center">Two-byte of LEB128 value</td><br>    </tr><br>    <tr><br>        <td colspan="8" align="center">First byte</td><br>        <td colspan="8" align="center">Second byte</td><br>    </tr><br>    <tr><br>        <td>1</td><br>        <td>bit6</td><br>        <td>bit5</td><br>        <td>bit4</td><br>        <td>bit3</td><br>        <td>bit2</td><br>        <td>bit1</td><br>        <td>bit0</td><br>        <td>0</td><br>        <td>bit13</td><br>        <td>bit12</td><br>        <td>bit11</td><br>        <td>bit10</td><br>        <td>bit9</td><br>        <td>bit8</td><br>        <td>bit7</td><br>    </tr><br></table><p>最长35位，可表示32位数据，大多数情况下数据值都很小，因此小于4字节空间，节约空间。</p><p>|dex header |</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文主要记录Android中dex文件的结构。&lt;/p&gt;
    
    </summary>
    
      <category term="虚拟机" scheme="http://yoursite.com/categories/%E8%99%9A%E6%8B%9F%E6%9C%BA/"/>
    
    
      <category term="虚拟机" scheme="http://yoursite.com/tags/%E8%99%9A%E6%8B%9F%E6%9C%BA/"/>
    
  </entry>
  
  <entry>
    <title>Java类文件结构</title>
    <link href="http://yoursite.com/2018/01/09/Java%E7%B1%BB%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/"/>
    <id>http://yoursite.com/2018/01/09/Java类文件结构/</id>
    <published>2018-01-09T15:15:35.481Z</published>
    <updated>2018-01-19T07:32:00.242Z</updated>
    
    <content type="html"><![CDATA[<p>本文主要记录Java中Class文件的结构。</p><a id="more"></a><h2 id="Java类文件结构"><a href="#Java类文件结构" class="headerlink" title="Java类文件结构"></a>Java类文件结构</h2><p>以8位字节为基础单位的二进制流，超过8字节的数据结构，高位在前低位在后进行分割</p><h3 id="class文件中的数据项："><a href="#class文件中的数据项：" class="headerlink" title="class文件中的数据项："></a>class文件中的数据项：</h3><table><thead><tr><th>类型</th><th>名称</th><th>数量</th></tr></thead><tbody><tr><td>u4</td><td>magic</td><td>1</td></tr><tr><td>u2</td><td>minor_version</td><td>1</td></tr><tr><td>u2</td><td>major_version</td><td>1</td></tr><tr><td>u2</td><td>constant_ pool_count</td><td>1</td></tr><tr><td>cp_info</td><td>constant_pool</td><td>constant_ pool_count - 1</td></tr><tr><td>u2</td><td>access_flags</td><td>1</td></tr><tr><td>u2</td><td>this_class</td><td>1</td></tr><tr><td>u2</td><td>super_class</td><td>1</td></tr><tr><td>u2</td><td>interfaces_count</td><td>1</td></tr><tr><td>u2</td><td>interfaces</td><td>interfaces_count</td></tr><tr><td>u2</td><td>fields_count</td><td>1</td></tr><tr><td>field_info</td><td>fields</td><td>fields_count</td></tr><tr><td>u2</td><td>methods_count</td><td>1</td></tr><tr><td>method_info</td><td>methods</td><td>methods_count</td></tr><tr><td>u2</td><td>attribute_count</td><td>1</td></tr><tr><td>attribute_info</td><td>attributes</td><td>attributes_count</td></tr></tbody></table><p>u1、u2、u4、u8分别代表1、2、4、8个字节</p><div align="left"><br>  <img src="https://raw.githubusercontent.com/Tristan-Hou/MarkdownImg/master/res/class%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84.png" width="500" height="500" alt="" aligh="center/"><br>   </div><h3 id="魔数：magic"><a href="#魔数：magic" class="headerlink" title="魔数：magic"></a>魔数：magic</h3><p>4个字节，代表class文件，固定值为0xCAFFBABE。如果不是这个值，文件不能被JVM识别</p><h3 id="版本号：minor-major-version"><a href="#版本号：minor-major-version" class="headerlink" title="版本号：minor/major_version"></a>版本号：minor/major_version</h3><p>2个字节，次/主版本号</p><h3 id="常量池："><a href="#常量池：" class="headerlink" title="常量池："></a>常量池：</h3><p>先以2字节的容量计数值constant_pool_count存储常量池中常量数量；常量池存放字符串、final常量值、当前类类名、字段名、方法名、字段和方法的描述符，当前类字段和方法引用信息等</p><ol><li>常量池中索引项从1开始，引用0的地方代表此处不引用任何常量池项</li><li>常量池存两类常量：字面量、符号引用</li><li>符号引用：<ul><li>类、接口全限定名：类似于java/lang/Object，用/不用.（java.lang.Object）</li><li>字段名称和描述符：所有的类型在描述符中都有对应的字符或字符串来对应。   </li></ul></li></ol><table><thead><tr><th>类型</th><th>对应字符或字符串</th><th>例子</th></tr></thead><tbody><tr><td>byte</td><td>B</td><td>—</td></tr><tr><td>char</td><td>C</td><td>—</td></tr><tr><td>double</td><td>D</td><td>—</td></tr><tr><td>float</td><td>F</td><td>—</td></tr><tr><td>int</td><td>I</td><td>—</td></tr><tr><td>long</td><td>J</td><td>—</td></tr><tr><td>short</td><td>S</td><td>—</td></tr><tr><td>boolean</td><td>Z</td><td>—</td></tr><tr><td>void</td><td>V</td><td>—</td></tr><tr><td>类、接口、枚举</td><td>“L”+全限定名+“;”</td><td>Ljava/lang/Object;</td></tr><tr><td>数组</td><td>n个“[”+元素类型字符/串</td><td>[[[Ljava/lang/Object;</td></tr></tbody></table><p>float和boolean对应的不是F和B，历史原因。</p><ul><li>方法名称和描述符：所有参数的类型列表和方法返回值——<code>(参数1类型参数2类型参数3类型 ...)返回值类型</code> 各个参数之间无空格</li></ul><table><thead><tr><th>方法描述符</th><th>方法声明</th></tr></thead><tbody><tr><td>()I</td><td>int getSize()</td></tr><tr><td>()Ljava/lang/String;</td><td>String toString()</td></tr><tr><td>([Ljava/lang/String;)V</td><td>void main(String[] args)</td></tr><tr><td>….</td></tr><tr><td>([BII)I</td><td>int read(byte[] b, int offm int len)</td></tr><tr><td>()[[Ljava/lang/Object;</td><td>Object[][] getObjectArray()</td></tr></tbody></table><ul><li>java没有<code>连接</code>步骤，是在需要一个class时候，由classloader加载class文件进行动态连接，从常量池里获取符号引用，创建类时解析、翻译到具体内存地址中。否则无法找到字段、方法对应的内存入口地址，无法被虚拟机使用</li></ul><h4 id="常量池数据项："><a href="#常量池数据项：" class="headerlink" title="常量池数据项："></a>常量池数据项：</h4><table><thead><tr><th>数据项类型</th><th>类型标志</th><th>描述</th></tr></thead><tbody><tr><td>CONSTANT_ Utf8_info</td><td>1</td><td>UTF-8编码的字符串</td></tr><tr><td>CONSTANT_ Integer_info</td><td>3</td><td>int类型字面值</td></tr><tr><td>CONSTANT_ Float_info</td><td>4</td><td>float类型字面值</td></tr><tr><td>CONSTANT_ Long_info</td><td>5</td><td>long类型字面值</td></tr><tr><td>CONSTANT_ Double_info</td><td>6</td><td>double类型字面值</td></tr><tr><td>CONSTANT_ Class_info</td><td>7</td><td>对一个类或接口的符号引用</td></tr><tr><td>CONSTANT_ String_info</td><td>8</td><td>String类型字面值</td></tr><tr><td>CONSTANT_ Fieldref_info</td><td>9</td><td>对一个字段的符号引用</td></tr><tr><td>CONSTANT_ Methodref_info</td><td>10</td><td>对一个类中声明的方法的符号引用</td></tr><tr><td>CONSTANT_ InterfaceMethodref_info</td><td>11</td><td>对一个接口中声明的方法的符号引用</td></tr><tr><td>CONSTANT_ NameAndType_info</td><td>12</td><td>对一个字段或方法的部分符号引用</td></tr></tbody></table><ul><li>每个类型中都有一个tag，位于数据项第一个字节，值为上表的“类型标志”</li></ul><h4 id="CONSTANT-Utf8-info"><a href="#CONSTANT-Utf8-info" class="headerlink" title="CONSTANT_Utf8_info"></a><code>CONSTANT_Utf8_info</code></h4><p>最基础的数据项，存储一个常量池字符串。</p><ul><li>常量池中所有的<code>字面量</code>几乎都是通过这个类型描述的，其他类型的常量池项只不过是对CONSTANT_Utf8_info的引用</li><li>首位tag值为1，随后2个字节是字符串长度length，接下来是字符串的存储值:</li></ul><div align="center"><br>  <img src="https://raw.githubusercontent.com/Tristan-Hou/MarkdownImg/master/res/CONSTANT_Utf8_info%E7%BB%93%E6%9E%84%E5%9B%BE.jpg" width="150" height="150" alt="CONSTANT_Utf8_info格式" align="center"><br>  </div><p>  因为class中文件中方法、字段都要引用CONSTANT<em> Utf8</em> info，因此此类型最大长度就是java中方法、字段名称的最大长度——即：2的16次方65535，如果方法名、变量名超过该值，就无法编译<br>  如果存储的String为Hello：</p>   <div align="center"><br>   <img src="https://raw.githubusercontent.com/Tristan-Hou/MarkdownImg/master/res/CONSTANT_Utf8_info%E7%BB%93%E6%9E%84%E4%BE%8B%E5%AD%90.jpg" width="150" height="150" alt="" aligh="center/"><br>   </div><ul><li>可包括的字符串：<ul><li>字符串常量：“Hello”等</li><li>全限定名：当前类、接口、枚举、直接父类、实现或继承的接口、引用的类型</li><li>方法、字段名称：本类的、引用的</li><li>方法、字段描述符：本类的、引用的</li><li>当前class文件中属性相关字符串：属性信息attribute</li></ul></li><li><p>更具体的例子：</p><pre><code>package com.jg.zhang;public class Programer extends Person {    static String company = &quot;CompanyA&quot;;    static{        System.out.println(&quot;staitc init&quot;);    }    String position;    Computer computer;    public Programer() {        this.position = &quot;engineer&quot;;        this.computer = new Computer();    }    public void working(){        System.out.println(&quot;coding...&quot;);        computer.working();    }} </code></pre><p> 反编译后取出CONSTANT_ Utf8_info相关数据项：</p><pre><code>#2 = Utf8      com/jg/zhang/Programer     //当前类的全限定名 #4 = Utf8      com/jg/zhang/Person        //父类的全限定名  #5 = Utf8      company                    //company字段的名称  #6 = Utf8      Ljava/lang/String;         //company和position字段的描述符  #7 = Utf8      position                   //position字段的名称  #8 = Utf8      computer                   //computer字段的名称  #9 = Utf8      Lcom/jg/zhang/Computer;    //computer字段的描述符  #10 = Utf8     &lt;clinit&gt;                   //类初始化方法（即静态初始化块）的方法名  #11 = Utf8     ()V                        //working方法的描述符  #12 = Utf8     Code                       //Code属性的属性名  #14 = Utf8     CompanyA                   //程序中的常量字符串  #19 = Utf8     java/lang/System           //所引用的System类的全限定名  #21 = Utf8     out                        //所引用的out字段的字段名  #22 = Utf8     Ljava/io/PrintStream;      //所引用的out字段的描述符  #24 = Utf8     staitc init                //程序中的常量字符串  #27 = Utf8     java/io/PrintStream        //所引用的PrintStream类的全限定名  #29 = Utf8     println                    //所引用的println方法的方法名  #30 = Utf8     (Ljava/lang/String;)V      //所引用的println方法的描述符  #31 = Utf8     LineNumberTable            //LineNumberTable属性的属性名  #32 = Utf8     LocalVariableTable         //LocalVariableTable属性的属性名  #33 = Utf8     &lt;init&gt;                     //当前类的构造方法的方法名  #41 = Utf8     com/jg/zhang/Computer      //所引用的Computer类的全限定名  #45 = Utf8     this                       //局部变量this的变量名  #46 = Utf8     Lcom/jg/zhang/Programer;   //局部变量this的描述符  #47 = Utf8     working                    //woking方法的方法名  #49 = Utf8     coding...                  //程序中的字符串常量  #52 = Utf8     SourceFile                 //SourceFile属性的属性名  #53 = Utf8     Programer.java             //当前类所在的源文件的文件名</code></pre></li></ul><h4 id="CONSTANT-NameAndType"><a href="#CONSTANT-NameAndType" class="headerlink" title="CONSTANT_NameAndType"></a><code>CONSTANT_NameAndType</code></h4><p>字段名称-字段描述符/方法名称-方法描述符</p><ul><li><p>首位tag为12，随后两个字节name<em>index，指向常量池中一个CONSTANT</em> Utf8_info，存储方法/字段名称，接下来两个字节descriptor<em>index指向一个CONSTANT</em> Utf8_info，存储方法/字段描述符</p><div align="center"><br><img src="https://raw.githubusercontent.com/Tristan-Hou/MarkdownImg/master/res/CONSTANT_NameAndType%E7%BB%93%E6%9E%84%E5%9B%BE.jpg" width="170" height="180" alt="" aligh="center/"><br></div></li><li><p>具体的例子:</p><pre><code>package com.jg.zhang;public class Person {    int age;    int getAge(){        return age;    }} </code></pre><p>  javap反编译:</p><pre><code>#1 = Class         #2         //  com/jg/zhang/Person  #2 = Utf8          com/jg/zhang/Person  #3 = Class         #4         //  java/lang/Object #4 = Utf8          java/lang/Object  #5 = Utf8          age  #6 = Utf8          I  #7 = Utf8          &lt;init&gt;  #8 = Utf8          ()V  #9 = Utf8          Code  #10 = Methodref    #3.#11     //  java/lang/Object.&quot;&lt;init&gt;&quot;:()V  #11 = NameAndType  #7:#8      //  &quot;&lt;init&gt;&quot;:()V  #12 = Utf8         LineNumberTable  #13 = Utf8         LocalVariableTable  #14 = Utf8         this  #15 = Utf8         Lcom/jg/zhang/Person; #16 = Utf8         getAge  #17 = Utf8         ()I  #18 = Fieldref     #1.#19     //  com/jg/zhang/Person.age:I  #19 = NameAndType  #5:#6      //  age:I  #20 = Utf8         SourceFile  #21 = Utf8         Person.java</code></pre><ul><li>第#11和#19是CONSTANT_NameAndType，#11引用了#7和#8，#19引用了#5和#6</li><li>第#7和#8是CONSTANT_Utf8_info，值为<init>和()V</init></li><li>CONSTANT_ NameAndType是对一个字段或方法的部分符号引用，换句话说，它应该指向一个被引用的字段或方法。如果类中定义了一个字段或方法，但是没有在别处被引用，那么常量池中是不会有相应的CONSTANT_NameAndType的</li><li>源码中有getAge()和编译器添加的构造函数两个方法，因为没有在别处调用，所有不存在相对应的CONSTANT_NameAndType</li><li>第#7和#8处的<init>、()V是父类Object的构造方法，因为子类的构造方法默认调用父类无参构造方法</init></li><li>第#5和#6存储age和I，描述了源码中的age字段。</li><li>在getAge()中引用了age，所有存在对应的CONSTANT_NameAndType</li></ul><div align="center"><br><img src="https://raw.githubusercontent.com/Tristan-Hou/MarkdownImg/master/res/Object%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%92%8CCONSTANT_NameAndType_info.jpg" width="400" height="400" alt="" aligh="center/"><br></div><div align="center"><br><img src="https://raw.githubusercontent.com/Tristan-Hou/MarkdownImg/master/res/age%E5%AD%97%E6%AE%B5%E5%92%8CCONSTANT_NameAndType_info.jpg" width="400" height="400" alt="" aligh="center/"><br></div></li></ul><h4 id="CONSTANT-Integer-info"><a href="#CONSTANT-Integer-info" class="headerlink" title="CONSTANT_Integer_info"></a><code>CONSTANT_Integer_info</code></h4><ul><li>首位tag为3，接下来4个字节bytes，存储int</li><li><p>示例代码：</p><pre><code>void printInt(){      System.out.println(65535);  }</code></pre><p>反编译：</p><pre><code>Constant pool:...#21 = Integer      65535...{...    void printInt();    flags:    Code:        stack=2, locals=1, args_size=1            0: getstatic    #15   // Field java/lang/System.out:Ljava/io/PrintStream;             3: ldc      #21   // int 65535            5: invokevirtual    #22   // Method java/io/PrintStream.println:(I)V            8: return        LineNumberTable:            line 6: 0            line 7: 8        LocalVariableTable:              Start  Length  Slot  Name   Signature               0       9     0    this   Lcom/jg/zhang/TestInt;   }  </code></pre><p><code>3: Idc #21</code>：Idc引用了第#21项，为65535</p></li></ul><h4 id="CONSTANT-Float-info"><a href="#CONSTANT-Float-info" class="headerlink" title="CONSTANT_Float_info"></a><code>CONSTANT_Float_info</code></h4><p>与CONSTANT_Integer_info类似，tag值为4，存储float类型值，4字节</p><h4 id="CONSTANT-Long-info"><a href="#CONSTANT-Long-info" class="headerlink" title="CONSTANT_Long_info"></a><code>CONSTANT_Long_info</code></h4><p>与CONSTANT_Integer_info类似，tag值为5，存储long类型值，8字节</p><h4 id="CONSTANT-Double-info"><a href="#CONSTANT-Double-info" class="headerlink" title="CONSTANT_Double_info"></a><code>CONSTANT_Double_info</code></h4><p>与CONSTANT_Integer_info类似，tag值为6，存储double类型值，8字节</p><h4 id="CONSTANT-String-info"><a href="#CONSTANT-String-info" class="headerlink" title="CONSTANT_String_info"></a><code>CONSTANT_String_info</code></h4><p>tag值为8，随后2个字节string_index是常量池引用，指向一个CONSTANT_Utf8_info，存放字符串</p><ul><li><p>代码：</p><pre><code>void printStrng(){      System.out.println(&quot;abcdef&quot;);   }</code></pre><p>反编译：</p><pre><code>Constant pool:...#21 = String     #22      //  abcdef  #22 = Utf8       abcdef ...{    void printStrng();        flags:        Code:             stack=2, locals=1, args_size=1                 0: getstatic     #15     // Field java/lang/System.out:Ljava/io/PrintStream;                 3: ldc           #21     // String abcdef                   5: invokevirtual #23     // Method java/io/PrintStream.println:(Ljava/lang/String;)V                  8: return             LineNumberTable:                 line 7: 0                  line 8: 8              LocalVariableTable:                  Start  Length  Slot  Name   Signature                   0      9      0   this   Lcom/jg/zhang/TestInt;}</code></pre><p> Idc指向#21，#21为CONSTANT_String_info，它又指向#22，#22是一个CONSTANT_Utf8_info，存储abcdef</p> <div align="center"><br><img src="https://raw.githubusercontent.com/Tristan-Hou/MarkdownImg/master/res/abcde%E5%92%8CCONSTANT_String_info.png" width="400" height="400" alt="" aligh="center/"><br></div></li></ul><h4 id="CONSTANT-Class-info"><a href="#CONSTANT-Class-info" class="headerlink" title="CONSTANT_Class_info"></a><code>CONSTANT_Class_info</code></h4><p>对类或者接口的符号引用。当前类信息，当前类引用，其他类引用</p><ul><li>tag值为7，随后2字节name_index指向一个CONSTANT_Utf8_info，存储类的全限定名或数组的描述符字符串<ul><li>Object类型：java/lang/Object </li><li>Object[]类型：[Ljava/lang/Object;</li></ul></li><li><p>结构图:</p><div align="center"><br><img src="https://raw.githubusercontent.com/Tristan-Hou/MarkdownImg/master/res/CONSTANT_Class_info%E5%AD%98%E5%82%A8%E5%B8%83%E5%B1%80.jpg" width="400" height="400" alt="" aligh="center/"><br></div></li><li><p>在一个类中引用了System这个类,常量池:</p><pre><code>Constant pool:    #16 = Class     #17    // java/lang/System    #17 = Utf8      java/lang/System</code></pre></li></ul><h4 id="CONSTANT-Fieldref-info"><a href="#CONSTANT-Fieldref-info" class="headerlink" title="CONSTANT_Fieldref_info"></a><code>CONSTANT_Fieldref_info</code></h4><p>对一个字段的符号引用。当前类中字段、其他类中字段、成员变量字段、静态变量字段</p><ul><li>tag值为9，随后2个字节class<em> index指向CONSTANT</em> Class<em> info，表示被引用的字段的类型、接口，接下来2字节name</em> and<em> type</em> index指向CONSTANT<em> NameAndType</em> info，表示被引用的字段的名称和描述符</li><li><p>代码：</p><pre><code>package com.jg.zhang;public class TestInt {   int a = 10;   void print(){       System.out.println(a);   }}</code></pre><p> 反编译：</p><pre><code>Constant pool:#1 = Class      #2        //  com/jg/zhang/TestInt#2 = Utf8       com/jg/zhang/TestInt...#5 = Utf8       a#6 = Utf8       I...#12 = Fieldref       #1.#13       //  com/jg/zhang/TestInt.a:I#13 = NameAndType      #5:#6        //  a:I ...{    void print();        flags:        Code:            stack=2, locals=1, args_size=1                0: getstatic     #19     // Field java/lang/System.out:Ljava/io/PrintStream;                  3: aload_0                4: getfield      #12     // Field a:I                  7: invokevirtual #25     // Method java/io/PrintStream.println:(I)V                10: return  } </code></pre><div align="center"><br><img src="https://raw.githubusercontent.com/Tristan-Hou/MarkdownImg/master/res/CONSTANT_Fieldref_info%E7%BB%93%E6%9E%84.jpg" width="600" height="500" alt="" aligh="center/"><br></div>  </li></ul><h4 id="CONSTANT-Methodref-info"><a href="#CONSTANT-Methodref-info" class="headerlink" title="CONSTANT_Methodref_info"></a><code>CONSTANT_Methodref_info</code></h4><p>对一个类中方法的符号引用。本类或其他类，成员方法、静态方法均可，但不会是对接口中的方法的符号引用。类似CONSTANT<em> Fieldref</em> info</p><ul><li>tag为10，2字节class<em> index指向CONSTANT</em> Class<em> info，表示被引用的方法所在的类型，2字节name</em> and<em> type</em> index指向CONSTANT<em> NameAndType</em> info，代表被引用的方法的名称和描述符</li><li><p>代码：</p><pre><code>//程序1package com.jg.zhang;public class Programer {    Computer computer;    public Programer(Computer computer){        this.computer = computer;    }      public void doWork(){        computer.calculate();     }  }//程序2package com.jg.zhang; public class Computer {      public void calculate() {         System.out.println(&quot;working...&quot;);      }  } </code></pre><p> 程序1调用了程序2，只反编译程序1：</p><pre><code>Constant pool:...#12 = Utf8     ()V...#20 = Methodref      #21.#23      //  com/jg/zhang/Computer.calculate:()V #21 = Class          #22          //  com/jg/zhang/Computer#22 = Utf8           com/jg/zhang/Computer#23 = NameAndType    #24:#12      //  calculate:()V#24 = Utf8           calculate...{    com.jg.zhang.Computer computer;        flags:       ...       public void doWork();           flags: ACC_PUBLIC             Code:                 stack=1, locals=1, args_size=1                     0: aload_0                     1: getfield      #13      // Field computer:Lcom/jg/zhang/Computer;                     4: invokevirtual #20      // Method com/jg/zhang/Computer.calculate:()V                     7: return }</code></pre><div align="center"><br><img src="https://raw.githubusercontent.com/Tristan-Hou/MarkdownImg/master/res/CONSTANT_Methodref_info%E7%BB%93%E6%9E%84%E5%9B%BE.jpg" width="600" height="500" alt="" aligh="center/"><br></div> </li></ul><h4 id="CONSTANT-InterfaceMethodref-info"><a href="#CONSTANT-InterfaceMethodref-info" class="headerlink" title="CONSTANT_InterfaceMethodref_info"></a><code>CONSTANT_InterfaceMethodref_info</code></h4><p>表示对一个接口方法的符号引用，不表示类中的方法。</p><ul><li>tag为11，2个字节的class<em>index指向CONSTANT</em> Class<em> info，表示被引用的而方法所在的接口，2字节name</em> and<em> type</em> index指向CONSTANT<em> NameAndType</em> info，被引用方法的名称和描述符。</li><li><p>代码：</p><pre><code>package com.jg.zhang;     public class Plane {        IFlyable flyable;     void flyToSky(){          flyable.fly();      }  }  ...package com.jg.zhang; public interface IFlyable {      void fly();  } </code></pre><p>反编译：</p><pre><code>Constant pool:...#8 = Utf8                ()V  ...#19 = InterfaceMethodref #20.#22     //  com/jg/zhang/IFlyable.fly:()V  #20 = Class              #21         //  com/jg/zhang/IFlyable  #21 = Utf8               com/jg/zhang/IFlyable  #22 = NameAndType        #23:#8      //  fly:()V  #23 = Utf8               fly {    com.jg.zhang.IFlyable flyable;         flags:       ...    void flyToSky();         flags:         Code:            stack=1, locals=1, args_size=1               0: aload_0               1: getfield    #17    // Field flyable:Lcom/jg/zhang/IFlyable;               4: invokeinterface   #19, 1    // InterfaceMethod com/jg/zhang/IFlyable.fly:()V               9: return }   </code></pre><div align="center"><br><img src="https://raw.githubusercontent.com/Tristan-Hou/MarkdownImg/master/res/CONSTANT_InterfaceMethodref_info%E7%BB%93%E6%9E%84%E5%9B%BE.jpg" width="600" height="500" alt="" aligh="center/"><br></div>  </li></ul><h3 id="访问标志"><a href="#访问标志" class="headerlink" title="访问标志"></a>访问标志</h3><p>access_flags：描述当前类或接口的访问修饰符，public、private等。同时有一个标志位记录这个class是类还是接口。</p><table><thead><tr><th>表知名</th><th>标志值</th><th>含义</th><th>针对的对象</th></tr></thead><tbody><tr><td>ACC_PUBLIC</td><td>0x0001</td><td>public类型</td><td>所有类型</td></tr><tr><td>ACC_FINAL</td><td>0x0010</td><td>final类型</td><td>类</td></tr><tr><td>ACC_SUPER</td><td>0x0020</td><td>使用新的invokespecial语义</td><td>类和接口</td></tr><tr><td>ACC_INTERFACE</td><td>0x0200</td><td>接口类型</td><td>接口</td></tr><tr><td>ACC_ABSTRACT</td><td>0x0400</td><td>抽象类型</td><td>类和接口</td></tr><tr><td>ACC_SYNTHETIC</td><td>0x1000</td><td>该类不由用户代码生成</td><td>所有类型</td></tr><tr><td>ACC_ANNOTATION</td><td>0x2000</td><td>注解类型</td><td>注解</td></tr><tr><td>ACC_ENUM</td><td>0x4000</td><td>枚举类型</td><td>枚举</td></tr></tbody></table><p>access_flags只能描述类、接口，不能描述字段或方法的修饰符</p><h3 id="类索引"><a href="#类索引" class="headerlink" title="类索引"></a>类索引</h3><p>this<em> class：2字节，对当前类的描述，指向一个CONSTANT</em> Class_ info，存放着当前类的全限定名</p><ul><li><p>代码：</p><p>   package com.jg.zhang;<br>   public class Person { </p><pre><code>int age;  int getAge(){      return age;  }  </code></pre><p>   }<br>反编译：</p><pre><code>Constant pool:  #1 = Class     #2     //  com/jg/zhang/Person  #2 = Utf8      com/jg/zhang/Person</code></pre></li></ul><h3 id="父类索引"><a href="#父类索引" class="headerlink" title="父类索引"></a>父类索引</h3><p>super<em> class：描述的是当前类的超类的信息，指向一个CONSTANT</em> Class_ info，存放着当前类的超类的全限定名（如果直接继承Object，那么super<em>class的索引值为0，也可以视为这个索引不引用任何常量池中的数据项）。其他类似this</em> class</p><h3 id="接口索引集合"><a href="#接口索引集合" class="headerlink" title="接口索引集合"></a>接口索引集合</h3><ul><li><p>interfaces_ count：当前类所实现的接口的数量或当前接口所继承的超接口数量（只有当前类直接实现的接口才会被统计， 如果当前类继承了另一个类， 而另一个类又实现了一个接口， 那么这个接口不会统计在当前类的interfaces_count中）</p></li><li><p>interfaces：共有interfaces<em> count个，指向CONSTANT</em> Class_ info，带表当前类直接实现、继承的接口的全限定名</p></li></ul><h3 id="字段表集合"><a href="#字段表集合" class="headerlink" title="字段表集合"></a>字段表集合</h3><ul><li>fields_count：当前类中定义的字段的个数，包括静态字段，但不包括从父类继承的字段<ul><li>编译器可能会自动添加某些字段，比如内部类拥有外部类的对象引用，所以class文件中字段数量可能多于源文件定义的数量</li></ul></li><li><p>fields：共有fields_count个，每个都是一个field_info</p><ul><li>field_info结构：</li></ul><div align="center"><br><img src="https://raw.githubusercontent.com/Tristan-Hou/MarkdownImg/master/res/field_info%E6%8F%8F%E8%BF%B0.jpg" width="150" height="160" alt="" aligh="center/"><br> </div> <ul><li>access_flags：2字节</li></ul><p>| 标志位名称 | 值 |含义 |设定者|<br>|—-|—-|—-|—-|<br>| ACC_PUBLIC | 0x0001 | 字段被设为public | 类和接口 |<br>| ACC_PRIVATE | 0x0002 | 字段被设为private | 类 |<br>| ACC_PROTECTED | 0x0004 | 字段被设为protected | 类 |<br>| ACC_STATIC | 0x0008 | 字段被设为static | 类和接口 |<br>| ACC_FINAL | 0x0010 | 字段被设为final | 类和接口 |<br>| ACC_VOLATILE | 0x0040 | 字段被设为volatile | 类 |<br>| ACC_TRANSIENT | 0x0080 | 字段被设为transient | 类 |</p><ul><li>name<em>index：2字节，指向常量池索引CONSTANT</em> Utf8_i nfo，描述当前字段名。</li><li>descriptor<em>index：2字节，指向常量池索引CONSTANT</em> Utf8_i nfo，描述当前字段描述符。</li><li>attribute_count：属性个数</li><li>attributes：属性信息，attribute_count个属性attribute_info。共有三种属性：ConstantValue， Deprecated， 和 Synthetic</li><li><p>代码：</p><pre><code>package com.jg.zhang; public class Programer extends Person{     private Computer computer;      public Programer(Computer computer){          this.computer = computer;      }      public void doWork(){         computer.calculate();      }  } </code></pre><p> 反编译：</p><pre><code>Constant pool: ...#5 = Utf8     computer  #6 = Utf8     Lcom/jg/zhang/Computer;...   {     private com.jg.zhang.Computer computer;      flags: ACC_PRIVATE}</code></pre></li></ul></li></ul><h3 id="方法表集合"><a href="#方法表集合" class="headerlink" title="方法表集合"></a>方法表集合</h3><ul><li>methods_count：当前的类中定义的方法的个数，包括静态方法，不包括父类继承的方法<ul><li>编译器会增加某些方法，例如<init>或<clinit>，因此可能或多于源文件方法数</clinit></init></li></ul></li><li><p>methods：共有methods_count个，每个都是一个method_info</p><ul><li><p>method_info结构：</p><div align="center"><br><img src="https://raw.githubusercontent.com/Tristan-Hou/MarkdownImg/master/res/method_info%E7%BB%93%E6%9E%84.jpg" width="150" height="160" alt="" aligh="center/"><br></div> </li><li><p>access_flags: 类似field_info，多了ACC_SYNCHRONIZED、ACC_NATIVE、ACC_ABSTRACT、ACC_STRICT</p></li><li>name_index：当前方法的方法名</li><li>descriptor_index：当前方法的描述符</li><li>attribute_count：属性个数</li><li>attributes：属性信息，attribute_count个属性attribute_info。有Code， Deprecated， Exceptions 和Synthetic</li></ul></li></ul><div align="center"><br>  <img src="https://raw.githubusercontent.com/Tristan-Hou/MarkdownImg/master/res/methods%E5%BC%95%E7%94%A8%E7%BB%93%E6%9E%84.jpg" width="600" height="500" alt="" aligh="center/"><br>   </div> <h3 id="属性表集合"><a href="#属性表集合" class="headerlink" title="属性表集合"></a>属性表集合</h3><ul><li>attributes_count：2字节，class文件中属性个数</li><li><p>attributes：attributes_count个，每一个都是一个attribute_info。在class文件顶层、field_info、method_info都会出现</p><ul><li>结构：</li></ul><div align="center"><br><img src="https://raw.githubusercontent.com/Tristan-Hou/MarkdownImg/master/res/attribute%E7%BB%93%E6%9E%84.jpg" width="130" height="100" alt="" aligh="center/"><br> </div> <ul><li>attribute_name_index：2字节，指向CONSTANT_Utf8_info，存放当前属性的名字</li><li>attribute_length：当前属性的长度</li><li>info：真实的属性数据</li></ul></li></ul><h4 id="几个重要的属性"><a href="#几个重要的属性" class="headerlink" title="几个重要的属性"></a>几个重要的属性</h4><h5 id="SourceFile属性："><a href="#SourceFile属性：" class="headerlink" title="SourceFile属性："></a>SourceFile属性：</h5><ul><li>顶层class文件中出现，描述了该类是从哪个源文件中编译来的，一个源文件中可以存在多个类</li></ul><div align="center"><br>  <img src="https://raw.githubusercontent.com/Tristan-Hou/MarkdownImg/master/res/SourceFile.jpg" width="200" height="180" alt="" aligh="center/"><br>   </div> <ul><li>attribute_name_index：“SourceFile”字符串</li><li>attribute_length：长度，2</li><li>sourcefile_index：指向CONSTANT_Utf8_info，生成该类的源文件的文件名，没有路径</li><li><p>代码：</p><pre><code>package com.jg.zhang;  public class Person {      int age;      int getAge(){          return age;      }  } </code></pre><p>反编译：</p><pre><code>public class com.jg.zhang.Person      SourceFile: &quot;Person.java&quot;  Constant pool:  ...      #20 = Utf8               SourceFile      #21 = Utf8               Person.java  ...</code></pre></li></ul><div align="center"><br>  <img src="https://raw.githubusercontent.com/Tristan-Hou/MarkdownImg/master/res/SourceFile%E5%B1%9E%E6%80%A7%E5%BC%95%E7%94%A8.jpg" width="600" height="500" alt="" aligh="center/"><br>   </div> <h5 id="InnerClasses属性"><a href="#InnerClasses属性" class="headerlink" title="InnerClasses属性"></a>InnerClasses属性</h5><p>顶层class文件中出现，描述的是内部类和外围类的关系.每个类可能有多个内部类， 而这些内部类中可能还有内部类， 多层嵌套。外围类中的InnerClasses属性必须描述它的所有内部类， 而内部类中的InnerClasses也必须描述它的外围类</p><h5 id="Synthetic属性"><a href="#Synthetic属性" class="headerlink" title="Synthetic属性"></a>Synthetic属性</h5><p>可以出现在filed_info、method_info和顶层的ClassFile中。表示这个字段， 方法或类是由编译器自动添加的，不是程序员写的，没有源文件（内部类对外部类的引用，构造方法等）</p>  <div align="center"><br>  <img src="https://raw.githubusercontent.com/Tristan-Hou/MarkdownImg/master/res/Synthetic.jpg" width="200" height="180" alt="" aligh="center/"><br>  </div><h5 id="ConstantValue属性"><a href="#ConstantValue属性" class="headerlink" title="ConstantValue属性"></a>ConstantValue属性</h5><p>出现在field_info中，是一个和字段相关的属性，静态基本类型字段或静态String字段会出现，为静态变量提供了一种初始化的方式（另一种是<clinit>初始化方法）</clinit></p><ul><li>结构：<div align="center"><br><img src="https://raw.githubusercontent.com/Tristan-Hou/MarkdownImg/master/res/ConstantValue%E5%B1%9E%E6%80%A7%E7%BB%93%E6%9E%84.jpg" width="200" height="180" alt="" aligh="center/"><br> </div> </li></ul><ul><li><p>constantvalue_index：根据field_info描述的字段的不同， 可以是不同类型的数据项——byte， short， char， int， boolean类型都指向一个CONSTANT_Integer_info（因为虽然java语言支持byte， short， char， boolean类型， 但是JVM却不支持这几种类型，class文件中的常量池中没有和这几个数据类型相对应的数据项， 这几中类型都被JVM在执行时当做int来对待，都对应CONSTANT_Integer_info）</p></li><li><p>代码：</p><pre><code>package com.jg.zhang;  public class Person {     static final int a = 1;     int age;     int getAge(){         return age;     }   } </code></pre><p>反编译：</p><pre><code>Constant pool:  ...    #7 = Utf8         ConstantValue      #8 = Integer      1  ...{      static final int a;          flags: ACC_STATIC, ACC_FINAL          ConstantValue: int 1      ...  }  </code></pre>  <div align="center"><br><img src="https://raw.githubusercontent.com/Tristan-Hou/MarkdownImg/master/res/ConstantValue%E5%B1%9E%E6%80%A7%E5%BC%95%E7%94%A8.jpg" width="500" height="400" alt="" aligh="center/"><br> </div> </li></ul><h5 id="Deprecated属性"><a href="#Deprecated属性" class="headerlink" title="Deprecated属性"></a>Deprecated属性</h5><p>可以出现在filed_info、method_info和顶层的ClassFile中,表示这个字段， 方法或类已经过时.用来支持源文件中的@deprecated注解</p><h5 id="Code属性"><a href="#Code属性" class="headerlink" title="Code属性"></a>Code属性</h5><p>非抽象方法都会有的属性，是方法的一个最重要的属性,存放的是方法的字节码指令和操作数栈，局部变量相关的信息</p> <div align="center"><br>  <img src="https://raw.githubusercontent.com/Tristan-Hou/MarkdownImg/master/res/Code%E5%B1%9E%E6%80%A7%E7%BB%93%E6%9E%84.jpg" width="500" height="400" alt="" aligh="center/"><br>   </div> <ul><li>attribute_name_index：属性名字“Code”</li><li>attribute_length：长度</li><li>max_stack：指定当前方法被执行引擎执行的时候， 在栈帧中需要分配的操作数栈的大小</li><li>max_locals：指定当前方法被执行引擎执行的时候， 在栈帧中需要分配的局部表量表的大小（方法中的局部变量包括方法的参数， 方法的默认参数this， 方法体中定义的变量， catch语句中的异常对象）</li><li>code_length：该方法的字节码的长度，每条字节码占一个字节</li><li>code：字节码指令</li><li>exception_table_length：异常表的大小</li><li>exception_table：对<code>方法体</code>中try-catch_finally的描述，包含exception_info</li><li>attributes_count：</li><li>attributes：存放了Code属性中的其他属性，LineNumberTable和LocalVariableTable</li></ul><h5 id="LineNumberTable属性"><a href="#LineNumberTable属性" class="headerlink" title="LineNumberTable属性"></a>LineNumberTable属性</h5><p>存在于Code属性中，它建立了字节码偏移量到源代码行号之间的联系</p><div align="center"><br>  <img src="https://raw.githubusercontent.com/Tristan-Hou/MarkdownImg/master/res/LineNumberTable%E5%B1%9E%E6%80%A7%E7%BB%93%E6%9E%84.jpg" width="500" height="400" alt="" aligh="center/"><br>   </div> <ul><li>line_number_info 结构描述了一条字节码和源码行号的对应关系</li><li>start_pc描述的字节码指令的偏移量，line_number描述的字节码指令对应的源码中的行号</li></ul><h5 id="LocalVariableTable属性"><a href="#LocalVariableTable属性" class="headerlink" title="LocalVariableTable属性"></a>LocalVariableTable属性</h5><p>存在于Code属性中，方法中的局部变量与源代码中的局部变量之间的对应关系。</p><div align="center"><br>  <img src="https://raw.githubusercontent.com/Tristan-Hou/MarkdownImg/master/res/LocalVariableTable%E5%B1%9E%E6%80%A7%E7%BB%93%E6%9E%84.jpg" width="500" height="400" alt="" aligh="center/"><br>   </div><ul><li>start_pc：局部变量的作用域的起始字节码偏移量</li><li>length：局部变量的作用域的大小——start_pc 到start_pc+length</li><li>name_index：局部变量的变量名</li><li>descriptor_index：局部变量的描述符</li><li>index：该方法被执行时，局部变量在栈帧中局部变量表中的位置</li></ul><h5 id="Exceptions属性"><a href="#Exceptions属性" class="headerlink" title="Exceptions属性"></a>Exceptions属性</h5><p>method_info中的attributes中。描述的是<code>方法声明</code>的可能会抛出的异常。</p><div align="center"><br>  <img src="https://raw.githubusercontent.com/Tristan-Hou/MarkdownImg/master/res/Exceptions%E5%B1%9E%E6%80%A7%E7%BB%93%E6%9E%84.jpg" width="500" height="400" alt="" aligh="center/"><br>   </div><ul><li>number_of_exceptions：</li><li>exceptions_index_table：number_of_exceptions个，每一个指向一个常量池中的CONSTANT_Class_info，描述了一个被抛出的异常的类型</li></ul><h3 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h3><p>知道方法是如何表示的， 字段是如何表示的， 继承是如何表示的 ， 方法体是如何表示的， 等等。 所有源文件中的东西， 都会在class文件中有相应的描述形式</p><div align="center"><br>  <img src="https://raw.githubusercontent.com/Tristan-Hou/MarkdownImg/master/res/method_info%E6%89%80%E6%9C%89%E5%B1%9E%E6%80%A7%E7%BB%93%E6%9E%84%E5%9B%BE.jpg" width="500" height="400" alt="" aligh="center/"><br>   </div>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文主要记录Java中Class文件的结构。&lt;/p&gt;
    
    </summary>
    
      <category term="虚拟机" scheme="http://yoursite.com/categories/%E8%99%9A%E6%8B%9F%E6%9C%BA/"/>
    
    
      <category term="虚拟机" scheme="http://yoursite.com/tags/%E8%99%9A%E6%8B%9F%E6%9C%BA/"/>
    
  </entry>
  
  <entry>
    <title>Android逆向分析笔记(2)</title>
    <link href="http://yoursite.com/2018/01/07/Android%E9%80%86%E5%90%91%E5%88%86%E6%9E%90%E7%AC%94%E8%AE%B0(2)/"/>
    <id>http://yoursite.com/2018/01/07/Android逆向分析笔记(2)/</id>
    <published>2018-01-07T13:21:52.557Z</published>
    <updated>2018-01-07T16:12:03.855Z</updated>
    
    <content type="html"><![CDATA[<p>笔记二主要记录dex文件格式，以及关于Android静态分析的知识点。<br><a id="more"></a></p><h2 id="dex文件格式与class文件格式"><a href="#dex文件格式与class文件格式" class="headerlink" title="dex文件格式与class文件格式"></a>dex文件格式与class文件格式</h2><h2 id="静态分析Android程序"><a href="#静态分析Android程序" class="headerlink" title="静态分析Android程序"></a>静态分析Android程序</h2><h3 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h3><pre><code>class Outer{    class Inner{}}//baksmali反编译后产生Outer$Inner.smali文件，打开，部分代码：...# instance field.field final synthetic this$0:L(package)Outer;</code></pre><p>synthetic属性代表这是被编译器合成的、虚构的，程序员本人并没有声明过该字段<br>this代表父类的引用，0表示引用的层数：</p><pre><code>public class Outer {                     //this$0    public class FirstInner {            //this$1        public class SecondInner {       //this$2            public class ThirdInner {}        }    }}</code></pre><h3 id="smali"><a href="#smali" class="headerlink" title="smali"></a>smali</h3><h2 id="ARM"><a href="#ARM" class="headerlink" title="ARM"></a>ARM</h2><h3 id="家族"><a href="#家族" class="headerlink" title="家族"></a>家族</h3><ul><li>Classic、Emnedded、Application三大家族</li><li>Classic： ARM1~ARM11，之后采用Cortex命名</li><li>Cortex型号：<ul><li>Cortex-A系列：智能手机、上网本、数字电视等。A8、A9、A10处理器</li><li>Cortex-M系列：微控制器，高能效、低功耗</li><li>Cortex-R系列</li></ul></li><li><p>相同版本处理器采用同一套ARM指令集：</p><p>| 架构 | 处理器家族 |<br>|——-| ——-|<br>|ARMv1 | ARM1 |<br>|ARMv2 | ARM2、ARM3 |<br>|ARMv3 | ARM6、ARM7 |<br>|ARMv4 | StribgARM、ARM7TDMI、ARM9TDMI |<br>|ARMv5 | ARM7EJ、ARM9E、ARM10E、XScale |<br>|ARMv6 | ARM11、ARMCortex-M |<br>|ARMv7 | ARM Cotex-A、ARM Cotex-M、ARM Cotex-R |<br>|ARMv8 | 32位、64位—进入64位时代|</p><p>ARMv7架构加入了VFPv3与NEON支持。NEON技术扩展了SIMD，加入了许多多媒体格式的硬编码，如：MPEG-4、H.264等。</p></li></ul><h3 id="原生程序的生成"><a href="#原生程序的生成" class="headerlink" title="原生程序的生成"></a>原生程序的生成</h3><p>C/C++在安卓中会生成ARM elf可执行文件。gcc编译原生c代码步骤：</p><ol><li>预处理：编译器将处理C代码中的预处理命令，#include、#defice等。(gcc -E hello.c -o hello.i)</li><li>编译：gcc检查代码规范性、语法错误等，随后将代码翻译成ARM汇编语言代码(gcc -S hello.i -o hello.s)</li><li>汇编：gcc调用汇编器将汇编代码汇编成二进制目标文件(gcc -c hello.s -o hello.o)</li><li>链接：编译器调用链接器将二进制目标文件连接成Android平台可执行的ARM原生程序(gcc hello.o -o hello)</li></ol><h3 id="NEON、VFP"><a href="#NEON、VFP" class="headerlink" title="NEON、VFP"></a>NEON、VFP</h3><p>ARMv7后加入了NEON指令集。如果想要使用，需要在Android.mk中加入一行“LOCAL_ARM_NEON := true”，还需要设置TARGET_ARCH_ABI值为armeabi-v7a。</p><p>可能有些手机还是不支持NEON和VFP，NDK中提供了一个cpufeatures库来检测。在Android.mk中加入“$(call import-module,android/cpufeatures)”，然后再C/C++代码头文件包含“cpu-feature.h”，它包含了android_getCpuFamily()、android_getCpuFeatures()、android_getCpuCount()。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;笔记二主要记录dex文件格式，以及关于Android静态分析的知识点。&lt;br&gt;
    
    </summary>
    
      <category term="Android" scheme="http://yoursite.com/categories/Android/"/>
    
    
      <category term="Dalvik虚拟机" scheme="http://yoursite.com/tags/Dalvik%E8%99%9A%E6%8B%9F%E6%9C%BA/"/>
    
  </entry>
  
  <entry>
    <title>零零碎碎的知识点</title>
    <link href="http://yoursite.com/2018/01/06/%E9%9B%B6%E9%9B%B6%E7%A2%8E%E7%A2%8E%E7%9A%84%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
    <id>http://yoursite.com/2018/01/06/零零碎碎的知识点/</id>
    <published>2018-01-06T09:28:39.102Z</published>
    <updated>2018-02-21T14:33:08.129Z</updated>
    
    <content type="html"><![CDATA[<p>学习过程中总是有一些杂七杂八的知识点，不太常用，却偶尔需要。跟大知识点放在一起时间久了不容易找，因此都放在这里。<br><a id="more"></a></p><h2 id="Java相关"><a href="#Java相关" class="headerlink" title="Java相关"></a>Java相关</h2><ol><li>方法描述符与方法签名：<a href="http://jianleixing.iteye.com/blog/2017732" target="_blank" rel="noopener">描述符与特征签名的区别</a>，特别注意泛型的影响</li><li>Android Studio下lint使用：(./gradlew :项目名:lint<code>Flavors名``buildTypes名</code>)./gradlew :Player_ad:lintNeon_market_D</li></ol><h2 id="NDK相关"><a href="#NDK相关" class="headerlink" title="NDK相关"></a>NDK相关</h2><ol><li>mk文件：隔离cpu、平台、ABI等差异，指出那些文件需要编译，编译特性要求等，帮助NDK实现交叉编译，创建so文件。</li><li>API：libc（C标准库）、libm（标准数学库）、libz（压缩库）、liblog（log库）。</li><li>android.useDeprecatedNdk=true 可配置在local.properties中，支持低版本编译</li><li><p>关于JNIEnv：</p><ul><li>C中：JNIEnv是一个结构体指针的别名，env是二级指针，一般用法需要传入env，例如：(*env)-&gt;NewStringUTF(env, “string”);</li><li>C++中：JNIEnv是一个结构体的别名，env是一级指针，使用时一般不需要传入env(因为C++中有this指针，代表着调用这functions的指针（其实就是二级指针）)，例如：env-&gt;NewStringUTF(“string”);</li><li><p>jdk的jni.h中：</p><p>   #ifdef __cplusplus</p><pre><code>typedef JNIEnv_ JNIEnv;</code></pre><p>   #else</p><pre><code>typedef const struct JNINativeInterface_ *JNIEnv;</code></pre><p>   #endif</p></li></ul><p>如果是C，JNIEnv就是JNINativeInterface<em>结构体的指针别名，如果是C++，JNIEnv就是JNIEnv</em>结构体的别名（JNIEnv封装了JNINativeInterface_)</p></li><li></li></ol><h2 id="C语言相关"><a href="#C语言相关" class="headerlink" title="C语言相关"></a>C语言相关</h2><ol><li><p>标准循环写法：</p><pre><code>int i=0;for(; i&lt;n; i++) {    printf(&quot;%d\n&quot;, i);}</code></pre><p>循环变量要抽取出来，否则在linux环境下gcc编译，报错</p></li><li>可以为一个指针变量赋值为NULL，NULL指针又叫空指针，定义在标准库中，值为0。操作系统中0地址通常不允许访问，因此指针被赋为NULL代表它不包含任何东西。</li><li>内存分配函数：<ul><li>void calloc(int num, int size):内存中动态分配num个长度为size的连续空间，初始化为0；</li><li>void free(void *address):释放address所指向的内存块，动态释放</li><li>void *malloc(int num):堆区释放一块指定大小的内存空间，数据不会初始化，值未知</li><li>void <em>relloc(void </em>address, int newsize):重新分配address内存，扩展到newsize大小</li></ul></li><li>关于relooc：<ul><li>如果当前内存段后面有需要的内存空间，且空闲空间足够，则扩展内存空间，返回原指针</li><li>如果当前内存段后的空闲空间不够，则使用堆中第一个能够满足这个要求的内存块，将目前的数据复制到性的位置，并将原内存段释放掉，返回新地址</li><li>如果申请失败，返回空指针NULL</li><li>释放内存时，只需要释放relloc返回的内存地址。因为原地址要么与relloc返回的地址相同，要么在重新分配新地址后，已经被释放</li></ul></li><li><p>内存泄漏：内存没有被释放（*p被赋新值前没有free()和置为NULL）</p><pre><code>void main() {    int *p = (int *)malloc(1024*1024*10*sizeof(int));    //free(p);    //p = NULL;    printf(&quot;%#x\n&quot;, p);    p = (int *)malloc(1024*1024*10*sizeof(int)*2);    free(p);    p = NULL;    printf(&quot;%#x\n&quot;, p);    getchar();}</code></pre></li><li>结构体大小：由于字节对齐，结构体变量大小，必须是最宽的基本数据类型的整数倍（空间换时间）</li><li>tyoedef：可以用来定义与平台无关的类型<ul><li>typedef long double REAL：支持long double的平台</li><li>typedef double REAL：不支持long double，支持double的平台</li><li>typedef float REAL：只支持float的平台</li><li>跨平台时，利用typedef可以很方便的修改代码</li><li>标准库中就使用了这个技巧，例如：size_t</li></ul></li><li>文件：<ul><li>写文本时，每遇到一个’\n’，会将其转换成’\r\n’(回车换行)。</li><li>读文本时，每遇到一个’\r\n’，会将其转换成’\n’。</li><li>但是读写二进制文件的时候并不会做以上转换。</li></ul></li><li><p>预处理器：文本替换工具，指示编译器在实际编译之前完成所需的预处理。</p><p>| 指令 |  描述 |<br>|—–| —–|<br>| #define | 定义宏 |<br>| #include | 包含一个源代码文件|<br>| #undef | 取消已定义的宏 |<br>| #ifdef | 如果宏已经定义，返回真 |<br>| #ifndef | 如果宏没有定义，返回假 |<br>| #if | 如果给定条件为真，则编译下面的代码 |<br>| #else #if |<br>| #elif | 如果前面的#if给定条件不为真，当前条件为真，则编译下面代码|<br>| #endif | 结束一个#if…#else条件编译块 |<br>| #error |当遇到标准错误时，输出错误消息 |<br>| #pragma | 使用标准化方法，向编译器发布特殊的命令到编译器中 |</p></li><li><p>&lt;&gt;表示引入的是系统头文件，“”表示引入得失第三方头文件</p></li></ol><h2 id="C-相关"><a href="#C-相关" class="headerlink" title="C++相关"></a>C++相关</h2><ol><li><p>命名空间：</p><pre><code>namespace namespace_name {   // 代码声明}</code></pre><p>调用：</p><pre><code>name::code;  // code 可以是变量或函数</code></pre><p>实例：</p><pre><code>#include &lt;iostream&gt;using namespace std;// 第一个命名空间namespace first_space{    void func(){       cout &lt;&lt; &quot;Inside first_space&quot; &lt;&lt; endl;    }}// 第二个命名空间namespace second_space{    void func(){       cout &lt;&lt; &quot;Inside second_space&quot; &lt;&lt; endl;    }}//using namespace first_space;void main (){    // 调用第一个命名空间中的函数   // func();   first_space::func();    // 调用第二个命名空间中的函数    second_space::func();    system(&quot;pause&quot;);}//结果输出：Inside first_spaceInside second_space</code></pre><p>嵌套的命名空间:</p><pre><code>namespace namespace_name1 {   // 代码声明   namespace namespace_name2 {      // 代码声明   }}</code></pre><p>可以访问namespace2里的成员：</p><pre><code>#include &lt;iostream&gt; using namespace std; // 第一个命名空间 namespace first_space{    void func(){       cout &lt;&lt; &quot;Inside first_space&quot; &lt;&lt; endl;    }    // 第二个命名空间    namespace second_space{       void func(){          cout &lt;&lt; &quot;Inside second_space&quot; &lt;&lt; endl;       }    } } using namespace first_space::second_space; int main (){    // 调用第二个命名空间中的函数    func();    system(&quot;pause&quot;);    return 0; } //结果输出： Inside second_space</code></pre></li><li><p>引用vs指针</p><ul><li>没有空引用</li><li>引用创建时必须初始化，指针可以在任意时间点初始化</li><li>引用一旦指向一个对象，就不能指向其他对象</li><li>引用作为函数返回类型，不能返回局部变量引用，因为超出了局部变量的作用范围，但可以返回静态类型</li></ul></li><li><p>C++中的结构体有一个this指针，指向自身。</p></li><li>定义一个函数，您可以为参数列表中后边的每一个参数指定默认值。当调用函数时，如果实际参数的值留空，则使用这个默认值。调用函数时，如果未传递参数的值，则会使用默认值，如果指定了值，则会忽略默认值，使用传递的值。</li><li><p>可以动态传入参数个数和类型</p><pre><code>void func(int i, ...) {    cout&lt;&lt;i&lt;&lt;endl;    //可变参数指针    va_list args_p;    //读取可变参数，i是最后一个固定参数    va_start(args_p, i);    int a = va_arg(args_p, int);    int b = va_arg(args_p, float);    ....    cout&lt;&lt; a &lt;&lt; endl;    cout&lt;&lt; b &lt;&lt; endl;    ...}void main() {    func(9, 10, 11.4f);}</code></pre></li><li><p>运算符重载：operator + 扩展符号(<code>operator+(const Box &amp;b)</code>)</p></li><li>类拷贝构造函数：浅拷贝(值拷贝)，拷贝的是指针的地址；深拷贝，拷贝的是指针指向的数据内容</li><li>友元(友元函数、友元类和友元成员函数)<ul><li>友元函数是指某些虽然不是类成员函数却能够访问类的所有成员的函数。类授予它的友元特别的访问权，这样该友元函数就能访问到类中的所有成员</li><li>友元类的所有成员函数都是另一个类的友元函数，都可以访问另一个类中的隐藏信息（包括私有成员和保护成员）。当希望一个类可以存取另一个类的私有成员时，可以将该类声明为另一类的友元类。</li><li>友元关系不能被继承；友元关系是单向的，不具有交换性。若类B是类A的友元，类A不一定是类B的友元，要看在类中是否有相应的声明；友元关系不具有传递性。若类B是类A的友元，类C是B的友元，类C不一定是类A的友元，同样要看类中是否有相应的申明</li><li>友元成员函数</li></ul></li><li>类的静态成员：static<ul><li>无论创建多少个类的对象，静态成员都只有一个副本</li><li>在类的所有对象中是共享的</li><li>如果不存在其他的初始化语句，在创建第一个对象时，所有的静态数据都会被初始化为零</li><li>我们不能把静态成员的初始化放置在类的定义中，但是可以在类的外部通过使用范围解析运算符 :: 来重新声明静态变量从而对它进行初始化</li></ul></li><li>基类 &amp; 派生类<ul><li>未使用访问修饰符默认为 private</li><li>一个派生类继承了所有的基类方法，但下列情况除外：<ul><li>基类的构造函数、析构函数和拷贝构造函数</li><li>基类的重载运算符</li><li>基类的友元函数</li></ul></li></ul></li><li>C++多态通过虚函数virtul实现<ul><li>纯虚函数：virtual int area() = 0;</li><li>虚函数表</li></ul></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;学习过程中总是有一些杂七杂八的知识点，不太常用，却偶尔需要。跟大知识点放在一起时间久了不容易找，因此都放在这里。&lt;br&gt;
    
    </summary>
    
      <category term="其他" scheme="http://yoursite.com/categories/%E5%85%B6%E4%BB%96/"/>
    
    
      <category term="零碎知识" scheme="http://yoursite.com/tags/%E9%9B%B6%E7%A2%8E%E7%9F%A5%E8%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>Android逆向分析笔记(1)</title>
    <link href="http://yoursite.com/2018/01/01/Android%E9%80%86%E5%90%91%E5%88%86%E6%9E%90%E7%AC%94%E8%AE%B0(1)/"/>
    <id>http://yoursite.com/2018/01/01/Android逆向分析笔记(1)/</id>
    <published>2018-01-01T13:04:55.021Z</published>
    <updated>2018-01-07T13:24:06.545Z</updated>
    
    <content type="html"><![CDATA[<p>最近在读《Android软件安全与逆向分析》，虽然不从事逆向研究的工作，但作为一名Android开发者，觉得了解一下相关知识还是有必要的。因此，这里记录下该书所阐述的主要知识点，方便记忆和理解。<br><a id="more"></a></p><h2 id="Dalvik虚拟机与Java虚拟机"><a href="#Dalvik虚拟机与Java虚拟机" class="headerlink" title="Dalvik虚拟机与Java虚拟机"></a>Dalvik虚拟机与Java虚拟机</h2><h3 id="区别："><a href="#区别：" class="headerlink" title="区别："></a>区别：</h3><ol><li>Java： 代码-编译-java字节码-class文件，虚拟机解码class文件<br>Dalvik：java字节码-Dalvik字节码-Dex，虚拟机解释Dex文件</li><li><p>Dalvik文件体积更小</p><ul><li>dx工具将java字节码-Dalvik字节码</li><li>dx工具对java文件重新排序，消除类文件中的冗余信息</li><li>例如：<ul><li>多个类文件相互引用，被引用的类文件中的方法签名会复制到引用类文件中;</li><li>常量字符串在多个类中也会被重复引用</li></ul></li><li>dx工具分解常量池，所有文件共享一个常量池</li></ul><p>class文件结构:<br><img src="https://raw.githubusercontent.com/Tristan-Hou/MarkdownImg/master/res/20151231114022450.png" alt=""></p></li></ol><p> <img src="https://raw.githubusercontent.com/Tristan-Hou/MarkdownImg/master/res/1514813806959.jpg" alt=""></p><ol><li><p>Java: 基于栈架构，需要频繁读写数据<br>Dalvik：寄存器架构，数据访问通过寄存器直接传递（lua的VM也是寄存器实现)</p><ul><li>无论是栈虚拟机，还是寄存器虚拟机，都要：<ul><li>将源码编译为VM指定的字节码</li><li>包含操作数，指令(处理操作数运算)，操作数数据结构</li><li>一个为所有函数操作的调用栈</li><li>指向下一条将要执行的指令位置的指令指针（PC计数器)——类似ARM架构cpu的PC寄存器与x86架构cpu的IP寄存器</li><li>操控指令的虚拟CPU<ul><li>根据PC计数器获取下一条指令</li><li>解析指令的具体含义(+/-/*/‘/等)</li><li>执行指令</li></ul></li></ul></li><li>注意：<ul><li>两种虚拟机都一个PC计数器和调用栈：<ul><li>Java：记录方法的调用，调用方法压入一帧，方法完成弹出。每一帧包括局部变量区(方法参数、局部变量)和求职栈(求值中间结果、别的方法参数)</li><li>Dalvik: 调用栈只维护一个寄存器列表</li></ul></li></ul></li></ul><p>示例代码：</p><pre><code>public class Hello {    public int foo(int a, int b) {        return (a + b) * (a - b);    }    public static void main(String[] argc) {        Hello hello = new Hello();        System.out.println(hello.foo(5, 3));    }}</code></pre><p>dx –dex –output=Hello.dex Hello.class可生成dex文件<br>javap -c -classpath . Hello查看foo的Java字节码：<br><img src="https://raw.githubusercontent.com/Tristan-Hou/MarkdownImg/master/res/1514822513334.jpg" alt=""><br>每条指令占1个字节，共8字节。<br>dexdump查看foodalvik字节码：<br><img src="https://raw.githubusercontent.com/Tristan-Hou/MarkdownImg/master/res/1514822614888.jpg" alt=""></p><ul><li>java虚拟机：更多的指令、更多的cpu消耗、更具可移植性</li><li>Dalvik：更多的指令空间、数据缓冲更易失效、更有利于进行AOT（ahead-of-time）优化（相对JIT）</li></ul></li></ol><h3 id="Dalvik寄存器"><a href="#Dalvik寄存器" class="headerlink" title="Dalvik寄存器"></a>Dalvik寄存器</h3><ul><li>ARM架构：Dalvik部分寄存器映射到ARM寄存器上，部分通过调用栈模拟</li><li>32位寄存器，64位通过连续的两个寄存器实现</li><li>根据Dalvik指令表，一共有2的16次方，0~65535个寄存器</li><li>每个虚拟机为一个进程维护一个调用栈，每个函数在函数头使用.registers指令指定用到的寄存器数目，虚拟机为其分配占空间，模拟寄存器。</li></ul><h2 id="Dalvik虚拟机特性"><a href="#Dalvik虚拟机特性" class="headerlink" title="Dalvik虚拟机特性"></a>Dalvik虚拟机特性</h2><h3 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h3><ul><li><p>内存分类：Java Object Heap、Bitmap Memory、Native Heap</p><ul><li>Java Object Heap：<ul><li>Java <code>new</code>出来的对象都存在这里。</li><li>Xms和Xmx分别控制最大/小值</li><li>为了避免Dalvik运行时不断调整此Heap大小而影响性能，一般让Xms=Xmx</li><li>ActivityManager.getMemoryClass获得该值。这个Java Object Heap就是平日所说的<code>Android应用程序进程能够使用的最大内存</code></li></ul></li></ul><p>代码：</p><pre><code>public class ActivityManager { /** * Return the approximate per-application memory class of the current * device.  This gives you an idea of how hard a memory limit you should * impose on your application to let the overall system work best.  The * returned value is in megabytes; the baseline Android memory class is * 16 (which happens to be the Java heap limit of those devices); some * device with more memory may return 24 or even higher numbers. */      public int getMemoryClass() {            return staticGetMemoryClass();        }      /** @hide */        static public int staticGetMemoryClass() {        // Really brain dead right now -- just take this from the configured        // vm heap size, and assume it is in megabytes and thus ends with &quot;m&quot;.            String vmHeapSize = SystemProperties.get(&quot;dalvik.vm.heapsize&quot;, &quot;16m&quot;);            return Integer.parseInt(vmHeapSize.substring(0, vmHeapSize.length()-1)); }  </code></pre><ul><li>Bitmap Memory:<ul><li>3.1之前，在Native Heap分配，但是同样算入Java Object Heap中，因此Bitmap+Java Object&lt;=Xmx</li><li>3.1之后，直接放入Java Object Heap，接受Gc管理</li></ul></li><li>Native Heap：<ul><li>malloc()分配。不收Gc限制。</li><li>Android内部代码使用了大量<code>智能指针</code>避免内存泄漏</li></ul></li></ul></li></ul><h3 id="GC"><a href="#GC" class="headerlink" title="GC"></a>GC</h3><ul><li>2.3之前：<ul><li>Stop-the-world，垃圾收集线程在执行时，其它线程都停止</li><li>Full heap collection，一次收集完全部的垃圾</li><li>程序中止通常大于100ms</li></ul></li><li>2.3之后：<ul><li>Cocurrent，垃圾收集线程与其它线程是并发执行的</li><li>Partial collection，一次可能只收集一部分垃圾</li><li>程序中止通常都小于5ms</li></ul></li></ul><p>Gc日志：</p><pre><code>D/dalvikvm(9050): GC_CONCURRENT freed 2049K, 65% free 3571K/9991K, external 4703K/5261K, paused 2ms+2ms</code></pre><ul><li>GC_CONCURRENT：GC原因</li><li>2049K：总共回收的内存</li><li>3571K/9991K：在9991K的Java Object Heap中，3571K正在使用的</li><li>4703K/5261K：在5261K的External Memory中，4703K正在使用的</li><li>2ms+2ms：垃圾收集造成的程序中止时间</li></ul><h3 id="JIT"><a href="#JIT" class="headerlink" title="JIT"></a>JIT</h3><ul><li>运行时编译，可以有效优化代码，但是占用运行时。</li><li>2-8原则：80%时间重复运行20%代码，因此只JIT这20%代码</li><li>假设某种情况，并作出代码优化–这种假设成立，保持现状–假设不成立，调整策略–只要假设不成立的情况很少发生或不发生，就会获得巨大收益–Gambing</li><li>例子：<ul><li>Java的同步，Lock和Unlock操作是非常耗时的，多线程环境下需要这种操作</li><li>但有些程序(同步块、同步函数)，很可能始终保持着单线程执行状态</li><li>JIT采取一种Lazy Unlocking机制：<ul><li>线程T1执行同步代码块C，先按照正常流程获取轻量级锁L1，线程T1的ID会记录在L1上</li><li>当T1离开C时，并不释放L1</li><li>当T1再次进入C，发现L1所有者就是自己，直接执行C</li><li>此时另一个线程T2需要执行C，发现L1已经被T1占有</li><li>JIT检查T1调用堆栈，查看T1是否还在执行C</li><li>是，将轻量级锁L1转换为重量级锁L2，将L2状态设置为锁定，再让T2在L2上睡眠</li><li>T1执行完C后，按正常流程释放L2，从而唤醒T2，执行C</li><li>否，直接将L1所有者标记为T2，T2执行C</li></ul></li></ul></li><li>静态语言无法这么做。”从这个角度来看，我们就可以说，静态编译语言（如C++）并不一定比在虚拟机上执行的语言（如Java）快，这是因为后者可以有一种强大的武器叫做JIT”——罗升阳</li><li><a href="http://blog.reverberate.org/2012/12/hello-jit-world-joy-of-simple-jits.html" target="_blank" rel="noopener">JIT实现原理简要介绍</a></li></ul><h3 id="NDK"><a href="#NDK" class="headerlink" title="NDK"></a>NDK</h3><h3 id="进程和线程管理"><a href="#进程和线程管理" class="headerlink" title="进程和线程管理"></a>进程和线程管理</h3><p>老罗看过Linux内核的几本书<a href="http://blog.csdn.net/luoshengyang/article/details/6557518" target="_blank" rel="noopener">老罗的Android学习之路</a><br><a href="https://dl.packetstormsecurity.net/papers/general/Abstract-Processor.pdf" target="_blank" rel="noopener">怎么实现一个虚拟的CPU</a></p><h2 id="Android程序的安装流程"><a href="#Android程序的安装流程" class="headerlink" title="Android程序的安装流程"></a>Android程序的安装流程</h2><ol><li>系统程序：开机时安装，没有安装界面。开机时启动PackageManagerService服务，扫描/system/app重新安装所有程序<ul><li>Zygote进程–SystemServer组件–PackageManagerService：<br><img src="https://raw.githubusercontent.com/Tristan-Hou/MarkdownImg/master/res/0_1315661784a77A.gif" alt=""><br>图片来源：<a href="http://blog.csdn.net/luoshengyang/article/details/6766010" target="_blank" rel="noopener">Android应用程序安装过程源代码分析</a></li></ul></li><li>Android市场安装：网络安装，没有安装界面。</li><li>Adb：没有安装界面</li><li>SD卡：apk文件安装，有安装界面。调用Android系统软件包packageinstall.apk安装。<ul><li>当点击apk，进入安装页面时，实际上就是启动了packageinstall.apk的PackageInstallerActivity，通过初始化PagcageManager和PackageParser.Packager对象，通过PackageUtil.getPackageInfo()解析程序包信息，主要解析Menifest.xml中的标签信息。失败，返回；成功，setContentView显示安装界面。</li><li>点击安装按钮–startActivity–InstallAppProgress.class–PackageManager.installPackage()。这个方法最终通过PackageManagerService.java实现。总之，通过installPackage()，进行了程序安装权限验证，随后进行安装或替换。</li><li>安装过程中会通过scanPackageLI()完成apk依赖库检测、签名验证、sharedUser的签名检查、更新Native库目录文件、组件名称检查等，这些都完成后，通过mInstaller.install()安装程序</li><li>install()构造字符串“install name uid gid”–transaction()–通过socket发送install指令–/system/bin/installd(常驻内存)–install指令函数installd.c do_install() install()–创建包路径/创建库路径/创建包目录/设置包目录权限/创建库目录/设置库目录权限/设置库目录所有者/设置包目录所有者–socket回传结果–成功/失败</li></ul></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近在读《Android软件安全与逆向分析》，虽然不从事逆向研究的工作，但作为一名Android开发者，觉得了解一下相关知识还是有必要的。因此，这里记录下该书所阐述的主要知识点，方便记忆和理解。&lt;br&gt;
    
    </summary>
    
      <category term="Android" scheme="http://yoursite.com/categories/Android/"/>
    
    
      <category term="Dalvik虚拟机" scheme="http://yoursite.com/tags/Dalvik%E8%99%9A%E6%8B%9F%E6%9C%BA/"/>
    
  </entry>
  
  <entry>
    <title>音视频学习（1）：基础概念</title>
    <link href="http://yoursite.com/2017/12/29/ffmpeg-1/"/>
    <id>http://yoursite.com/2017/12/29/ffmpeg-1/</id>
    <published>2017-12-29T07:37:30.869Z</published>
    <updated>2017-12-29T07:37:30.869Z</updated>
    
    <content type="html"><![CDATA[<h2 id="视频格式"><a href="#视频格式" class="headerlink" title="视频格式"></a>视频格式</h2><p>主流编码格式有H.261/H.263/H.264/H.265，运动静止图像专家组的M-JPEG和国际标准化组织运动图像专家组的MPEG系列标准，还有Real-Networks的RealVideo、微软的WMV和苹果的QuickTime等。目前主要学习<code>H264</code></p><a id="more"></a><ul><li><code>低码率</code>：同等图像质量数据量只有MPEG2的1/8，MPEG4的1/3</li><li><code>高质量</code>：连续、流畅的高质量图像（DVD质量）</li><li><code>容错能力强</code>：提供了在不稳定网络环境下容易发生的丢包等错误的必要工具</li><li><code>网络适应性强</code>：H.264提供了网络抽象层，似的H.264的文件能容易的在不同网络上传输（互联网、CDMA、GPRS、WCDMA、CDMA2000等）</li><li><code>高压缩率</code>：压缩比可达到102：1（同等图像质量，是MPEG2的2倍以上，MPEG4的1.5~2倍——原始文件大小88G，MPEG2压缩后变成3.5G，压缩比25：1，而H.264压缩后为879M）</li></ul><h2 id="音频格式"><a href="#音频格式" class="headerlink" title="音频格式"></a>音频格式</h2><ul><li>采样率：模-数转换过程中单位时间内采样次数</li><li>单声道声音文件：采样数据为8位的短整数（short int 00H-FFH）</li><li>双声道立体声文件：每次采样数据为一个16位的整数（int），高8位为左声道，低8位为右声道</li></ul><p>采样记录的是振幅，因此：</p><ul><li>1字节（8bit）只能记录256个数</li><li>2字节（16bit）可以记录65536个数，属于CD标准</li><li>4字节（32bit）没必要</li></ul><p>可根据mav文件大小、采样率、采样大小估算播放时长：424.644字节，“属性-&gt;摘要”里看到“22050Hz/16bit/立体声”，因此每秒传输速率就是22050 <em> 16 </em> 2 = 705600（bit/s)，字节：705600 / 8 = 88200（字节/s)。而包装标准PCM（脉冲编码调制）格式的WAVE文件（<em>.wav）中至少带有42个字节头信息，所以播放时长为：<br>（424644 - 42） / (22050 </em> 16 * 2 / 8) ≈ 4.8140816s</p><p>上面例子中，705600（bit/s)也叫<code>比特率/取样率</code> kbps/bps。压缩的音频文件常用位速表示，cd音质的MP3是:128kbps/44100Hz。</p><p>PCM采样顺序图：<br><img src="https://raw.githubusercontent.com/Tristan-Hou/MarkdownImg/master/res/31215112_8x2j37.gif" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;视频格式&quot;&gt;&lt;a href=&quot;#视频格式&quot; class=&quot;headerlink&quot; title=&quot;视频格式&quot;&gt;&lt;/a&gt;视频格式&lt;/h2&gt;&lt;p&gt;主流编码格式有H.261/H.263/H.264/H.265，运动静止图像专家组的M-JPEG和国际标准化组织运动图像专家组的MPEG系列标准，还有Real-Networks的RealVideo、微软的WMV和苹果的QuickTime等。目前主要学习&lt;code&gt;H264&lt;/code&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="FFmpeg" scheme="http://yoursite.com/categories/FFmpeg/"/>
    
    
      <category term="FFmpeg" scheme="http://yoursite.com/tags/FFmpeg/"/>
    
      <category term="音视频" scheme="http://yoursite.com/tags/%E9%9F%B3%E8%A7%86%E9%A2%91/"/>
    
  </entry>
  
  <entry>
    <title>Xndroid学习篇(1)——初次编译</title>
    <link href="http://yoursite.com/2017/12/29/Xndroid-learn-1/"/>
    <id>http://yoursite.com/2017/12/29/Xndroid-learn-1/</id>
    <published>2017-12-29T07:37:30.868Z</published>
    <updated>2017-12-29T07:37:30.869Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul><li>项目地址：<a href="https://github.com/XndroidDev/Xndroid" target="_blank" rel="noopener">Xndroid</a></li><li>作者：<a href="https://github.com/XndroidDev" target="_blank" rel="noopener">XndroidDev</a></li></ul><h3 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h3><p>首次fork该项目，并进行编译时，编译时不能通过的我用的是最新的Andorid Studio 3.0）——当然有一个原因是我的NDK路径不对，汗~     </p><a id="more"></a><ul><li>首先，直接sync会报错： </li></ul><p><img src="https://raw.githubusercontent.com/Tristan-Hou/MarkdownImg/master/res/xndroid-shrinker-error.jpg" alt=""></p><blockquote><p>Error:Resource shrinker cannot be used for libraries.</p></blockquote><p>原因是library中使用了混淆，并移除了无用的资源文件，解决办法就是把该library中的<code>shrinkResources</code>字段移除——按理说这个字段应该加上，但没想到其他更好的办法，暂时移除吧。 </p><p>接下来应该可以sync成功了。</p><ul><li>随后开始编译，编译失败：</li></ul><p><img src="https://raw.githubusercontent.com/Tristan-Hou/MarkdownImg/master/res/xndroid-compileNdk.jpg" alt=""></p><blockquote><p>:app:ompileDebugNdk</p></blockquote><p>根据提示，我们可以知道这是由于<code>gradle.properties</code>文件中使用了<code>useDeprecatedNdk</code>，而这个东西已经“no longer supported and will removed in the next version”。所以我们有两个解决办法：</p><ol><li>使用<code>CMake</code> 和 <code>ndk-build integration</code>;</li><li>使用<code>android.deprecatedNdkCompileLease=xxx</code>这么一个东西，“for another 60 days”</li></ol><p>我们先实验第二种方法，直接添加“android.deprecatedNdkCompileLease=1511832698813”到gradle.properties文件中，编译成功。</p><p>但是这种方法貌似只能延续60天？那60天后呢？所以为了长久之计，我们还是该使用第一种方法——CMake。</p><hr><p>我是参考这个人的博客<a href="http://blog.csdn.net/qiantanlong/article/details/78622990" target="_blank" rel="noopener">《NDK开发之——Error: Flag android.useDeprecatedNdk is no longer supported爬坑》</a>实现的。具体做法就是：</p><ol><li><p>先将app项目下的<code>build.gradle</code>文件内容按该博客所讲，补齐。</p><pre><code>android {    compileSdkVersion 26    buildToolsVersion &apos;26.0.2&apos;    defaultConfig {        applicationId &quot;net.xndroid&quot;        minSdkVersion 14        targetSdkVersion 26       ndk {          moduleName &quot;sockvpn&quot;  //设置库(so)文件名称          //设置支持的so库架构          abiFilters &quot;armeabi-v7a&quot;, &quot;arm64-v8a&quot;, &quot;armeabi&quot;          ldLibs &quot;log&quot;      }      externalNativeBuild {          cmake {              cppFlags &quot;&quot;          }      }    versionCode 13    versionName &quot;1.1.3-3&quot;    testInstrumentationRunner &quot;android.support.test.runner.AndroidJUnitRunner&quot;    }    buildTypes {        release {            minifyEnabled false            proguardFiles getDefaultProguardFile(&apos;proguard-android.txt&apos;), &apos;proguard-rules.pro&apos;        }    }    sourceSets.main {        jniLibs.srcDirs = [&apos;src/main/jni&apos;]    }    externalNativeBuild {        cmake {            path &quot;CMakeLists.txt&quot;        }    }}</code></pre></li></ol><p>其中<code>moduleName &quot;sockvpn&quot;</code>对应了<code>src/main/jni</code>下的<code>sockvpn</code>文件名，也就是编译出来侯的.so文件名，当然你可以起其他名字。</p><p><code>jniLibs.srcDirs = [&#39;src/main/jni&#39;]</code>是你的jni路径。当然你也看到了，这里还有一个文件<code>CMakeLists.txt</code>，你需要在app项目的根目录创建它。</p><ol><li><p>创建<code>CMakeLists.txt</code>：</p><pre><code># For more information about using CMake with Android Studio, read the# documentation: https://d.android.com/studio/projects/add-native-code.html# Sets the minimum version of CMake required to build the native library.cmake_minimum_required(VERSION 3.4.1)# Creates and names a library, sets it as either STATIC# or SHARED, and provides the relative paths to its source code.# You can define multiple libraries, and CMake builds them for you.# Gradle automatically packages shared libraries with your APK.add_library( # Sets the name of the library.             sockvpn             # Sets the library as a shared library.             SHARED             # Provides a relative path to your source file(s).             src/main/jni/sockvpn.c )# Searches for a specified prebuilt library and stores the path as a# variable. Because CMake includes system libraries in the search path by# default, you only need to specify the name of the public NDK library# you want to add. CMake verifies that the library exists before# completing its build.find_library( # Sets the name of the path variable.              log-lib              # Specifies the name of the NDK library that              # you want CMake to locate.              log )# Specifies libraries CMake should link to your target library. You# can link multiple libraries, such as libraries you define in this# build script, prebuilt third-party libraries, or system libraries.target_link_libraries( # Specifies the target library.                       sockvpn                       # Links the target library to the log library                       # included in the NDK.                       ${log-lib} )</code></pre><p>你只需要将上面博客里所讲的一些模块名字改为<code>sockvpn</code>即可。</p></li></ol><p>至于他说的<code>native-lib.cpp</code>，我们不需要。</p><ol><li>编译，成功。<br><img src="https://raw.githubusercontent.com/Tristan-Hou/MarkdownImg/master/res/xndroid-compile-success.jpg" alt=""></li></ol><p>##总结<br>刚开始接触NDK，很多东西都不懂，因此这么一个小小的编译，都浪费了许多时间。<br>这里所说的<code>CMakeLists.txt</code>内容，我并不能完全懂，还有项目里的<code>Android.mk</code>/<code>Application.mk</code>，我也不是很懂。<br><code>所以说，还是要多学习一个啊！提高姿势水平~</code></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;项目地址：&lt;a href=&quot;https://github.com/XndroidDev/Xndroid&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Xndroid&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;作者：&lt;a href=&quot;https://github.com/XndroidDev&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;XndroidDev&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;编译&quot;&gt;&lt;a href=&quot;#编译&quot; class=&quot;headerlink&quot; title=&quot;编译&quot;&gt;&lt;/a&gt;编译&lt;/h3&gt;&lt;p&gt;首次fork该项目，并进行编译时，编译时不能通过的我用的是最新的Andorid Studio 3.0）——当然有一个原因是我的NDK路径不对，汗~     &lt;/p&gt;
    
    </summary>
    
      <category term="NDK" scheme="http://yoursite.com/categories/NDK/"/>
    
    
      <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
      <category term="NDK" scheme="http://yoursite.com/tags/NDK/"/>
    
  </entry>
  
</feed>
