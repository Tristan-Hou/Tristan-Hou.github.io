<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Tristan的博客</title>
  
  <subtitle>Tristan-Hou</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-01-03T17:21:01.180Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Tristan-Hou</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Android逆向分析笔记(1)</title>
    <link href="http://yoursite.com/2018/01/01/Android%E9%80%86%E5%90%91%E5%88%86%E6%9E%90%E7%AC%94%E8%AE%B0(1)/"/>
    <id>http://yoursite.com/2018/01/01/Android逆向分析笔记(1)/</id>
    <published>2018-01-01T13:04:55.021Z</published>
    <updated>2018-01-03T17:21:01.180Z</updated>
    
    <content type="html"><![CDATA[<p>最近在读《Android软件安全与逆向分析》，虽然不从事逆向研究的工作，但作为一名Android开发者，觉得了解一下相关知识还是有必要的。因此，这里记录下该书所阐述的主要知识点，方便记忆和理解。<br><a id="more"></a></p><h2 id="Dalvik虚拟机与Java虚拟机"><a href="#Dalvik虚拟机与Java虚拟机" class="headerlink" title="Dalvik虚拟机与Java虚拟机"></a>Dalvik虚拟机与Java虚拟机</h2><h3 id="区别："><a href="#区别：" class="headerlink" title="区别："></a>区别：</h3><ol><li>Java： 代码-编译-java字节码-class文件，虚拟机解码class文件<br>Dalvik：java字节码-Dalvik字节码-Dex，虚拟机解释Dex文件</li><li><p>Dalvik文件体积更小</p><ul><li>dx工具将java字节码-Dalvik字节码</li><li>dx工具对java文件重新排序，消除类文件中的冗余信息</li><li>例如：<ul><li>多个类文件相互引用，被引用的类文件中的方法签名会复制到引用类文件中;</li><li>常量字符串在多个类中也会被重复引用</li></ul></li><li>dx工具分解常量池，所有文件共享一个常量池</li></ul><p><img src="https://raw.githubusercontent.com/Tristan-Hou/MarkdownImg/master/res/1514813806959.jpg" alt=""></p></li><li><p>Java: 基于栈架构，需要频繁读写数据<br>Dalvik：寄存器架构，数据访问通过寄存器直接传递（lua的VM也是寄存器实现)</p><ul><li>无论是栈虚拟机，还是寄存器虚拟机，都要：<ul><li>将源码编译为VM指定的字节码</li><li>包含操作数，指令(处理操作数运算)，操作数数据结构</li><li>一个为所有函数操作的调用栈</li><li>指向下一条将要执行的指令位置的指令指针（PC计数器)——类似ARM架构cpu的PC寄存器与x86架构cpu的IP寄存器</li><li>操控指令的虚拟CPU<ul><li>根据PC计数器获取下一条指令</li><li>解析指令的具体含义(+/-/*/‘/等)</li><li>执行指令</li></ul></li></ul></li><li>注意：<ul><li>两种虚拟机都一个PC计数器和调用栈：<ul><li>Java：记录方法的调用，调用方法压入一帧，方法完成弹出。每一帧包括局部变量区(方法参数、局部变量)和求职栈(求值中间结果、别的方法参数)</li><li>Dalvik: 调用栈只维护一个寄存器列表</li></ul></li></ul></li></ul><p>示例代码：</p><pre><code>public class Hello {    public int foo(int a, int b) {        return (a + b) * (a - b);    }    public static void main(String[] argc) {        Hello hello = new Hello();        System.out.println(hello.foo(5, 3));    }}</code></pre><p>dx –dex –output=Hello.dex Hello.class可生成dex文件<br>javap -c -classpath . Hello查看foo的Java字节码：<br><img src="https://raw.githubusercontent.com/Tristan-Hou/MarkdownImg/master/res/1514822513334.jpg" alt=""><br>每条指令占1个字节，共8字节。<br>dexdump查看foodalvik字节码：<br><img src="https://raw.githubusercontent.com/Tristan-Hou/MarkdownImg/master/res/1514822614888.jpg" alt=""></p><ul><li>java虚拟机：更多的指令、更多的cpu消耗、更具可移植性</li><li>Dalvik：更多的指令空间、数据缓冲更易失效、更有利于进行AOT（ahead-of-time）优化（相对JIT）</li></ul></li></ol><h3 id="Dalvik寄存器"><a href="#Dalvik寄存器" class="headerlink" title="Dalvik寄存器"></a>Dalvik寄存器</h3><ul><li>ARM架构：Dalvik部分寄存器映射到ARM寄存器上，部分通过调用栈模拟</li><li>32位寄存器，64位通过连续的两个寄存器实现</li><li>根据Dalvik指令表，一共有2的16次方，0~65535个寄存器</li><li>每个虚拟机为一个进程维护一个调用栈，每个函数在函数头使用.registers指令指定用到的寄存器数目，虚拟机为其分配占空间，模拟寄存器。</li></ul><h2 id="Dalvik虚拟机特性"><a href="#Dalvik虚拟机特性" class="headerlink" title="Dalvik虚拟机特性"></a>Dalvik虚拟机特性</h2><h3 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h3><ul><li><p>内存分类：Java Object Heap、Bitmap Memory、Native Heap</p><ul><li>Java Object Heap：<ul><li>Java <code>new</code>出来的对象都存在这里。</li><li>Xms和Xmx分别控制最大/小值</li><li>为了避免Dalvik运行时不断调整此Heap大小而影响性能，一般让Xms=Xmx</li><li>ActivityManager.getMemoryClass获得该值。这个Java Object Heap就是平日所说的<code>Android应用程序进程能够使用的最大内存</code></li></ul></li></ul><p>代码：</p><pre><code>public class ActivityManager { /** * Return the approximate per-application memory class of the current * device.  This gives you an idea of how hard a memory limit you should * impose on your application to let the overall system work best.  The * returned value is in megabytes; the baseline Android memory class is * 16 (which happens to be the Java heap limit of those devices); some * device with more memory may return 24 or even higher numbers. */      public int getMemoryClass() {            return staticGetMemoryClass();        }      /** @hide */        static public int staticGetMemoryClass() {        // Really brain dead right now -- just take this from the configured        // vm heap size, and assume it is in megabytes and thus ends with &quot;m&quot;.            String vmHeapSize = SystemProperties.get(&quot;dalvik.vm.heapsize&quot;, &quot;16m&quot;);            return Integer.parseInt(vmHeapSize.substring(0, vmHeapSize.length()-1)); }  </code></pre><ul><li>Bitmap Memory:<ul><li>3.1之前，在Native Heap分配，但是同样算入Java Object Heap中，因此Bitmap+Java Object&lt;=Xmx</li><li>3.1之后，直接放入Java Object Heap，接受Gc管理</li></ul></li><li>Native Heap：<ul><li>malloc()分配。不收Gc限制。</li><li>Android内部代码使用了大量<code>智能指针</code>避免内存泄漏</li></ul></li></ul></li></ul><h3 id="GC"><a href="#GC" class="headerlink" title="GC"></a>GC</h3><ul><li>2.3之前：<ul><li>Stop-the-world，垃圾收集线程在执行时，其它线程都停止</li><li>Full heap collection，一次收集完全部的垃圾</li><li>程序中止通常大于100ms</li></ul></li><li>2.3之后：<ul><li>Cocurrent，垃圾收集线程与其它线程是并发执行的</li><li>Partial collection，一次可能只收集一部分垃圾</li><li>程序中止通常都小于5ms</li></ul></li></ul><p>Gc日志：</p><pre><code>D/dalvikvm(9050): GC_CONCURRENT freed 2049K, 65% free 3571K/9991K, external 4703K/5261K, paused 2ms+2ms</code></pre><ul><li>GC_CONCURRENT：GC原因</li><li>2049K：总共回收的内存</li><li>3571K/9991K：在9991K的Java Object Heap中，3571K正在使用的</li><li>4703K/5261K：在5261K的External Memory中，4703K正在使用的</li><li>2ms+2ms：垃圾收集造成的程序中止时间</li></ul><h3 id="JIT"><a href="#JIT" class="headerlink" title="JIT"></a>JIT</h3><ul><li>运行时编译，可以有效优化代码，但是占用运行时。</li><li>2-8原则：80%时间重复运行20%代码，因此只JIT这20%代码</li><li>假设某种情况，并作出代码优化–这种假设成立，保持现状–假设不成立，调整策略–只要假设不成立的情况很少发生或不发生，就会获得巨大收益–Gambing</li><li>例子：<ul><li>Java的同步，Lock和Unlock操作是非常耗时的，多线程环境下需要这种操作</li><li>但有些程序(同步块、同步函数)，很可能始终保持着单线程执行状态</li><li>JIT采取一种Lazy Unlocking机制：<ul><li>线程T1执行同步代码块C，先按照正常流程获取轻量级锁L1，线程T1的ID会记录在L1上</li><li>当T1离开C时，并不释放L1</li><li>当T1再次进入C，发现L1所有者就是自己，直接执行C</li><li>此时另一个线程T2需要执行C，发现L1已经被T1占有</li><li>JIT检查T1调用堆栈，查看T1是否还在执行C</li><li>是，将轻量级锁L1转换为重量级锁L2，将L2状态设置为锁定，再让T2在L2上睡眠</li><li>T1执行完C后，按正常流程释放L2，从而唤醒T2，执行C</li><li>否，直接将L1所有者标记为T2，T2执行C</li></ul></li></ul></li><li>静态语言无法这么做。”从这个角度来看，我们就可以说，静态编译语言（如C++）并不一定比在虚拟机上执行的语言（如Java）快，这是因为后者可以有一种强大的武器叫做JIT”——罗升阳</li><li><a href="http://blog.reverberate.org/2012/12/hello-jit-world-joy-of-simple-jits.html" target="_blank" rel="noopener">JIT实现原理简要介绍</a></li></ul><h3 id="NDK"><a href="#NDK" class="headerlink" title="NDK"></a>NDK</h3><h3 id="进程和线程管理"><a href="#进程和线程管理" class="headerlink" title="进程和线程管理"></a>进程和线程管理</h3><p>老罗看过Linux内核的几本书<a href="http://blog.csdn.net/luoshengyang/article/details/6557518" target="_blank" rel="noopener">老罗的Android学习之路</a><br><a href="https://dl.packetstormsecurity.net/papers/general/Abstract-Processor.pdf" target="_blank" rel="noopener">怎么实现一个虚拟的CPU</a></p><h2 id="Android程序的安装流程"><a href="#Android程序的安装流程" class="headerlink" title="Android程序的安装流程"></a>Android程序的安装流程</h2><ol><li>系统程序：开机时安装，没有安装界面。开机时启动PackageManagerService服务，扫描/system/app重新安装所有程序<ul><li>Zygote进程–SystemServer组件–PackageManagerService：<br><img src="https://raw.githubusercontent.com/Tristan-Hou/MarkdownImg/master/res/0_1315661784a77A.gif" alt=""><br>图片来源：<a href="http://blog.csdn.net/luoshengyang/article/details/6766010" target="_blank" rel="noopener">Android应用程序安装过程源代码分析</a></li></ul></li><li>Android市场安装：网络安装，没有安装界面。</li><li>Adb：没有安装界面</li><li>SD卡：apk文件安装，有安装界面。调用Android系统软件包packageinstall.apk安装。<ul><li>当点击apk，进入安装页面时，实际上就是启动了packageinstall.apk的PackageInstallerActivity，通过初始化PagcageManager和PackageParser.Packager对象，通过PackageUtil.getPackageInfo()解析程序包信息，主要解析Menifest.xml中的标签信息。失败，返回；成功，setContentView显示安装界面。</li><li>点击安装按钮–startActivity–InstallAppProgress.class–PackageManager.installPackage()。这个方法最终通过PackageManagerService.java实现。总之，通过installPackage()，进行了程序安装权限验证，随后进行安装或替换。</li><li>安装过程中会通过scanPackageLI()完成apk依赖库检测、签名验证、sharedUser的签名检查、更新Native库目录文件、组件名称检查等，这些都完成后，通过mInstaller.install()安装程序</li><li>install()构造字符串“install name uid gid”–transaction()–通过socket发送install指令–/system/bin/installd(常驻内存)–install指令函数installd.c do_install() install()–创建包路径/创建库路径/创建包目录/设置包目录权限/创建库目录/设置库目录权限/设置库目录所有者/设置包目录所有者–socket回传结果–成功/失败</li></ul></li></ol><h2 id="dex文件格式与class文件格式"><a href="#dex文件格式与class文件格式" class="headerlink" title="dex文件格式与class文件格式"></a>dex文件格式与class文件格式</h2>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近在读《Android软件安全与逆向分析》，虽然不从事逆向研究的工作，但作为一名Android开发者，觉得了解一下相关知识还是有必要的。因此，这里记录下该书所阐述的主要知识点，方便记忆和理解。&lt;br&gt;
    
    </summary>
    
      <category term="Android" scheme="http://yoursite.com/categories/Android/"/>
    
    
      <category term="虚拟机" scheme="http://yoursite.com/tags/%E8%99%9A%E6%8B%9F%E6%9C%BA/"/>
    
  </entry>
  
  <entry>
    <title>音视频学习（1）：基础概念</title>
    <link href="http://yoursite.com/2017/12/29/ffmpeg-1/"/>
    <id>http://yoursite.com/2017/12/29/ffmpeg-1/</id>
    <published>2017-12-29T07:37:30.869Z</published>
    <updated>2017-12-29T07:37:30.869Z</updated>
    
    <content type="html"><![CDATA[<h2 id="视频格式"><a href="#视频格式" class="headerlink" title="视频格式"></a>视频格式</h2><p>主流编码格式有H.261/H.263/H.264/H.265，运动静止图像专家组的M-JPEG和国际标准化组织运动图像专家组的MPEG系列标准，还有Real-Networks的RealVideo、微软的WMV和苹果的QuickTime等。目前主要学习<code>H264</code></p><a id="more"></a><ul><li><code>低码率</code>：同等图像质量数据量只有MPEG2的1/8，MPEG4的1/3</li><li><code>高质量</code>：连续、流畅的高质量图像（DVD质量）</li><li><code>容错能力强</code>：提供了在不稳定网络环境下容易发生的丢包等错误的必要工具</li><li><code>网络适应性强</code>：H.264提供了网络抽象层，似的H.264的文件能容易的在不同网络上传输（互联网、CDMA、GPRS、WCDMA、CDMA2000等）</li><li><code>高压缩率</code>：压缩比可达到102：1（同等图像质量，是MPEG2的2倍以上，MPEG4的1.5~2倍——原始文件大小88G，MPEG2压缩后变成3.5G，压缩比25：1，而H.264压缩后为879M）</li></ul><h2 id="音频格式"><a href="#音频格式" class="headerlink" title="音频格式"></a>音频格式</h2><ul><li>采样率：模-数转换过程中单位时间内采样次数</li><li>单声道声音文件：采样数据为8位的短整数（short int 00H-FFH）</li><li>双声道立体声文件：每次采样数据为一个16位的整数（int），高8位为左声道，低8位为右声道</li></ul><p>采样记录的是振幅，因此：</p><ul><li>1字节（8bit）只能记录256个数</li><li>2字节（16bit）可以记录65536个数，属于CD标准</li><li>4字节（32bit）没必要</li></ul><p>可根据mav文件大小、采样率、采样大小估算播放时长：424.644字节，“属性-&gt;摘要”里看到“22050Hz/16bit/立体声”，因此每秒传输速率就是22050 <em> 16 </em> 2 = 705600（bit/s)，字节：705600 / 8 = 88200（字节/s)。而包装标准PCM（脉冲编码调制）格式的WAVE文件（<em>.wav）中至少带有42个字节头信息，所以播放时长为：<br>（424644 - 42） / (22050 </em> 16 * 2 / 8) ≈ 4.8140816s</p><p>上面例子中，705600（bit/s)也叫<code>比特率/取样率</code> kbps/bps。压缩的音频文件常用位速表示，cd音质的MP3是:128kbps/44100Hz。</p><p>PCM采样顺序图：<br><img src="https://raw.githubusercontent.com/Tristan-Hou/MarkdownImg/master/res/31215112_8x2j37.gif" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;视频格式&quot;&gt;&lt;a href=&quot;#视频格式&quot; class=&quot;headerlink&quot; title=&quot;视频格式&quot;&gt;&lt;/a&gt;视频格式&lt;/h2&gt;&lt;p&gt;主流编码格式有H.261/H.263/H.264/H.265，运动静止图像专家组的M-JPEG和国际标准化组织运动图像专家组的MPEG系列标准，还有Real-Networks的RealVideo、微软的WMV和苹果的QuickTime等。目前主要学习&lt;code&gt;H264&lt;/code&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="FFmpeg" scheme="http://yoursite.com/categories/FFmpeg/"/>
    
    
      <category term="FFmpeg" scheme="http://yoursite.com/tags/FFmpeg/"/>
    
      <category term="音视频" scheme="http://yoursite.com/tags/%E9%9F%B3%E8%A7%86%E9%A2%91/"/>
    
  </entry>
  
  <entry>
    <title>Xndroid学习篇(1)——初次编译</title>
    <link href="http://yoursite.com/2017/12/29/Xndroid-learn-1/"/>
    <id>http://yoursite.com/2017/12/29/Xndroid-learn-1/</id>
    <published>2017-12-29T07:37:30.868Z</published>
    <updated>2017-12-29T07:37:30.869Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul><li>项目地址：<a href="https://github.com/XndroidDev/Xndroid" target="_blank" rel="noopener">Xndroid</a></li><li>作者：<a href="https://github.com/XndroidDev" target="_blank" rel="noopener">XndroidDev</a></li></ul><h3 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h3><p>首次fork该项目，并进行编译时，编译时不能通过的我用的是最新的Andorid Studio 3.0）——当然有一个原因是我的NDK路径不对，汗~     </p><a id="more"></a><ul><li>首先，直接sync会报错： </li></ul><p><img src="https://raw.githubusercontent.com/Tristan-Hou/MarkdownImg/master/res/xndroid-shrinker-error.jpg" alt=""></p><blockquote><p>Error:Resource shrinker cannot be used for libraries.</p></blockquote><p>原因是library中使用了混淆，并移除了无用的资源文件，解决办法就是把该library中的<code>shrinkResources</code>字段移除——按理说这个字段应该加上，但没想到其他更好的办法，暂时移除吧。 </p><p>接下来应该可以sync成功了。</p><ul><li>随后开始编译，编译失败：</li></ul><p><img src="https://raw.githubusercontent.com/Tristan-Hou/MarkdownImg/master/res/xndroid-compileNdk.jpg" alt=""></p><blockquote><p>:app:ompileDebugNdk</p></blockquote><p>根据提示，我们可以知道这是由于<code>gradle.properties</code>文件中使用了<code>useDeprecatedNdk</code>，而这个东西已经“no longer supported and will removed in the next version”。所以我们有两个解决办法：</p><ol><li>使用<code>CMake</code> 和 <code>ndk-build integration</code>;</li><li>使用<code>android.deprecatedNdkCompileLease=xxx</code>这么一个东西，“for another 60 days”</li></ol><p>我们先实验第二种方法，直接添加“android.deprecatedNdkCompileLease=1511832698813”到gradle.properties文件中，编译成功。</p><p>但是这种方法貌似只能延续60天？那60天后呢？所以为了长久之计，我们还是该使用第一种方法——CMake。</p><hr><p>我是参考这个人的博客<a href="http://blog.csdn.net/qiantanlong/article/details/78622990" target="_blank" rel="noopener">《NDK开发之——Error: Flag android.useDeprecatedNdk is no longer supported爬坑》</a>实现的。具体做法就是：</p><ol><li><p>先将app项目下的<code>build.gradle</code>文件内容按该博客所讲，补齐。</p><pre><code>android {    compileSdkVersion 26    buildToolsVersion &apos;26.0.2&apos;    defaultConfig {        applicationId &quot;net.xndroid&quot;        minSdkVersion 14        targetSdkVersion 26       ndk {          moduleName &quot;sockvpn&quot;  //设置库(so)文件名称          //设置支持的so库架构          abiFilters &quot;armeabi-v7a&quot;, &quot;arm64-v8a&quot;, &quot;armeabi&quot;          ldLibs &quot;log&quot;      }      externalNativeBuild {          cmake {              cppFlags &quot;&quot;          }      }    versionCode 13    versionName &quot;1.1.3-3&quot;    testInstrumentationRunner &quot;android.support.test.runner.AndroidJUnitRunner&quot;    }    buildTypes {        release {            minifyEnabled false            proguardFiles getDefaultProguardFile(&apos;proguard-android.txt&apos;), &apos;proguard-rules.pro&apos;        }    }    sourceSets.main {        jniLibs.srcDirs = [&apos;src/main/jni&apos;]    }    externalNativeBuild {        cmake {            path &quot;CMakeLists.txt&quot;        }    }}</code></pre></li></ol><p>其中<code>moduleName &quot;sockvpn&quot;</code>对应了<code>src/main/jni</code>下的<code>sockvpn</code>文件名，也就是编译出来侯的.so文件名，当然你可以起其他名字。</p><p><code>jniLibs.srcDirs = [&#39;src/main/jni&#39;]</code>是你的jni路径。当然你也看到了，这里还有一个文件<code>CMakeLists.txt</code>，你需要在app项目的根目录创建它。</p><ol><li><p>创建<code>CMakeLists.txt</code>：</p><pre><code># For more information about using CMake with Android Studio, read the# documentation: https://d.android.com/studio/projects/add-native-code.html# Sets the minimum version of CMake required to build the native library.cmake_minimum_required(VERSION 3.4.1)# Creates and names a library, sets it as either STATIC# or SHARED, and provides the relative paths to its source code.# You can define multiple libraries, and CMake builds them for you.# Gradle automatically packages shared libraries with your APK.add_library( # Sets the name of the library.             sockvpn             # Sets the library as a shared library.             SHARED             # Provides a relative path to your source file(s).             src/main/jni/sockvpn.c )# Searches for a specified prebuilt library and stores the path as a# variable. Because CMake includes system libraries in the search path by# default, you only need to specify the name of the public NDK library# you want to add. CMake verifies that the library exists before# completing its build.find_library( # Sets the name of the path variable.              log-lib              # Specifies the name of the NDK library that              # you want CMake to locate.              log )# Specifies libraries CMake should link to your target library. You# can link multiple libraries, such as libraries you define in this# build script, prebuilt third-party libraries, or system libraries.target_link_libraries( # Specifies the target library.                       sockvpn                       # Links the target library to the log library                       # included in the NDK.                       ${log-lib} )</code></pre><p>你只需要将上面博客里所讲的一些模块名字改为<code>sockvpn</code>即可。</p></li></ol><p>至于他说的<code>native-lib.cpp</code>，我们不需要。</p><ol><li>编译，成功。<br><img src="https://raw.githubusercontent.com/Tristan-Hou/MarkdownImg/master/res/xndroid-compile-success.jpg" alt=""></li></ol><p>##总结<br>刚开始接触NDK，很多东西都不懂，因此这么一个小小的编译，都浪费了许多时间。<br>这里所说的<code>CMakeLists.txt</code>内容，我并不能完全懂，还有项目里的<code>Android.mk</code>/<code>Application.mk</code>，我也不是很懂。<br><code>所以说，还是要多学习一个啊！提高姿势水平~</code></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;项目地址：&lt;a href=&quot;https://github.com/XndroidDev/Xndroid&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Xndroid&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;作者：&lt;a href=&quot;https://github.com/XndroidDev&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;XndroidDev&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;编译&quot;&gt;&lt;a href=&quot;#编译&quot; class=&quot;headerlink&quot; title=&quot;编译&quot;&gt;&lt;/a&gt;编译&lt;/h3&gt;&lt;p&gt;首次fork该项目，并进行编译时，编译时不能通过的我用的是最新的Andorid Studio 3.0）——当然有一个原因是我的NDK路径不对，汗~     &lt;/p&gt;
    
    </summary>
    
      <category term="NDK" scheme="http://yoursite.com/categories/NDK/"/>
    
    
      <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
      <category term="NDK" scheme="http://yoursite.com/tags/NDK/"/>
    
  </entry>
  
</feed>
