<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Tristan的博客</title>
  
  <subtitle>Tristan-Hou</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-01-02T06:51:16.827Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Tristan-Hou</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Android逆向分析笔记(1)</title>
    <link href="http://yoursite.com/2018/01/01/%E6%9C%AA%E5%91%BD%E5%90%8D/"/>
    <id>http://yoursite.com/2018/01/01/未命名/</id>
    <published>2018-01-01T13:04:55.021Z</published>
    <updated>2018-01-02T06:51:16.827Z</updated>
    
    <content type="html"><![CDATA[<p>最近在读《Android软件安全与逆向分析》，虽然不从事逆向研究的工作，但作为一名Android开发者，觉得了解一下相关知识还是有必要的。因此，这里记录下该书所阐述的主要知识点，方便记忆和理解。<br><a id="more"></a></p><h2 id="Dalvik虚拟机与Java虚拟机的区别"><a href="#Dalvik虚拟机与Java虚拟机的区别" class="headerlink" title="Dalvik虚拟机与Java虚拟机的区别"></a>Dalvik虚拟机与Java虚拟机的区别</h2><ol><li>Java： 代码-编译-java字节码-class文件，虚拟机解码class文件<br>Dalvik：java字节码-Dalvik字节码-Dex，虚拟机解释Dex文件</li><li>Dalvik文件体积更小<ul><li>dx工具将java字节码-Dalvik字节码</li><li>dx工具对java文件重新排序，消除类文件中的冗余信息</li><li>例如：<ul><li>多个类文件相互引用，被引用的类文件中的方法签名会复制到引用类文件中;</li><li>常量字符串在多个类中也会被重复引用</li></ul></li><li>dx工具分解常量池，所有文件共享一个常量池</li></ul></li></ol><p><img src="https://raw.githubusercontent.com/Tristan-Hou/MarkdownImg/master/res/1514813806959.jpg" alt=""></p><ol><li><p>Java: 基于栈架构，需要频繁读写数据<br>Dalvik：寄存器架构，数据访问通过寄存器直接传递（lua的VM也是寄存器实现)</p><ul><li>无论是栈虚拟机，还是寄存器虚拟机，都要：<ul><li>将源码编译为VM指定的字节码</li><li>包含操作数，指令(处理操作数运算)，操作数数据结构</li><li>一个为所有函数操作的调用栈</li><li>指向下一条将要执行的指令位置的指令指针（PC计数器)——类似ARM架构cpu的PC寄存器与x86架构cpu的IP寄存器</li><li>操控指令的虚拟CPU<ul><li>根据PC计数器获取下一条指令</li><li>解析指令的具体含义(+/-/*/‘/等)</li><li>执行指令</li></ul></li></ul></li><li>注意：<ul><li>两种虚拟机都一个PC计数器和调用栈：<ul><li>Java：记录方法的调用，调用方法压入一帧，方法完成弹出。每一帧包括局部变量区(方法参数、局部变量)和求职栈(求值中间结果、别的方法参数)</li><li>Dalvik: 调用栈只维护一个寄存器列表</li></ul></li></ul></li></ul><p>示例代码：</p><pre><code>public class Hello {    public int foo(int a, int b) {        return (a + b) * (a - b);    }    public static void main(String[] argc) {        Hello hello = new Hello();        System.out.println(hello.foo(5, 3));    }}</code></pre><p>dx –dex –output=Hello.dex Hello.class可生成dex文件<br>javap -c -classpath . Hello查看foo的Java字节码：<br><img src="https://raw.githubusercontent.com/Tristan-Hou/MarkdownImg/master/res/1514822513334.jpg" alt=""><br>每条指令占1个字节，共8字节。<br>dexdump查看foodalvik字节码：<br><img src="https://raw.githubusercontent.com/Tristan-Hou/MarkdownImg/master/res/1514822614888.jpg" alt=""></p></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近在读《Android软件安全与逆向分析》，虽然不从事逆向研究的工作，但作为一名Android开发者，觉得了解一下相关知识还是有必要的。因此，这里记录下该书所阐述的主要知识点，方便记忆和理解。&lt;br&gt;
    
    </summary>
    
      <category term="Android" scheme="http://yoursite.com/categories/Android/"/>
    
    
      <category term="虚拟机" scheme="http://yoursite.com/tags/%E8%99%9A%E6%8B%9F%E6%9C%BA/"/>
    
  </entry>
  
  <entry>
    <title>音视频学习（1）：基础概念</title>
    <link href="http://yoursite.com/2017/12/29/ffmpeg-1/"/>
    <id>http://yoursite.com/2017/12/29/ffmpeg-1/</id>
    <published>2017-12-29T07:37:30.869Z</published>
    <updated>2017-12-29T07:37:30.869Z</updated>
    
    <content type="html"><![CDATA[<h2 id="视频格式"><a href="#视频格式" class="headerlink" title="视频格式"></a>视频格式</h2><p>主流编码格式有H.261/H.263/H.264/H.265，运动静止图像专家组的M-JPEG和国际标准化组织运动图像专家组的MPEG系列标准，还有Real-Networks的RealVideo、微软的WMV和苹果的QuickTime等。目前主要学习<code>H264</code></p><a id="more"></a><ul><li><code>低码率</code>：同等图像质量数据量只有MPEG2的1/8，MPEG4的1/3</li><li><code>高质量</code>：连续、流畅的高质量图像（DVD质量）</li><li><code>容错能力强</code>：提供了在不稳定网络环境下容易发生的丢包等错误的必要工具</li><li><code>网络适应性强</code>：H.264提供了网络抽象层，似的H.264的文件能容易的在不同网络上传输（互联网、CDMA、GPRS、WCDMA、CDMA2000等）</li><li><code>高压缩率</code>：压缩比可达到102：1（同等图像质量，是MPEG2的2倍以上，MPEG4的1.5~2倍——原始文件大小88G，MPEG2压缩后变成3.5G，压缩比25：1，而H.264压缩后为879M）</li></ul><h2 id="音频格式"><a href="#音频格式" class="headerlink" title="音频格式"></a>音频格式</h2><ul><li>采样率：模-数转换过程中单位时间内采样次数</li><li>单声道声音文件：采样数据为8位的短整数（short int 00H-FFH）</li><li>双声道立体声文件：每次采样数据为一个16位的整数（int），高8位为左声道，低8位为右声道</li></ul><p>采样记录的是振幅，因此：</p><ul><li>1字节（8bit）只能记录256个数</li><li>2字节（16bit）可以记录65536个数，属于CD标准</li><li>4字节（32bit）没必要</li></ul><p>可根据mav文件大小、采样率、采样大小估算播放时长：424.644字节，“属性-&gt;摘要”里看到“22050Hz/16bit/立体声”，因此每秒传输速率就是22050 <em> 16 </em> 2 = 705600（bit/s)，字节：705600 / 8 = 88200（字节/s)。而包装标准PCM（脉冲编码调制）格式的WAVE文件（<em>.wav）中至少带有42个字节头信息，所以播放时长为：<br>（424644 - 42） / (22050 </em> 16 * 2 / 8) ≈ 4.8140816s</p><p>上面例子中，705600（bit/s)也叫<code>比特率/取样率</code> kbps/bps。压缩的音频文件常用位速表示，cd音质的MP3是:128kbps/44100Hz。</p><p>PCM采样顺序图：<br><img src="https://raw.githubusercontent.com/Tristan-Hou/MarkdownImg/master/res/31215112_8x2j37.gif" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;视频格式&quot;&gt;&lt;a href=&quot;#视频格式&quot; class=&quot;headerlink&quot; title=&quot;视频格式&quot;&gt;&lt;/a&gt;视频格式&lt;/h2&gt;&lt;p&gt;主流编码格式有H.261/H.263/H.264/H.265，运动静止图像专家组的M-JPEG和国际标准化组织运动图像专家组的MPEG系列标准，还有Real-Networks的RealVideo、微软的WMV和苹果的QuickTime等。目前主要学习&lt;code&gt;H264&lt;/code&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="FFmpeg" scheme="http://yoursite.com/categories/FFmpeg/"/>
    
    
      <category term="FFmpeg" scheme="http://yoursite.com/tags/FFmpeg/"/>
    
      <category term="音视频" scheme="http://yoursite.com/tags/%E9%9F%B3%E8%A7%86%E9%A2%91/"/>
    
  </entry>
  
  <entry>
    <title>Xndroid学习篇(1)——初次编译</title>
    <link href="http://yoursite.com/2017/12/29/Xndroid-learn-1/"/>
    <id>http://yoursite.com/2017/12/29/Xndroid-learn-1/</id>
    <published>2017-12-29T07:37:30.868Z</published>
    <updated>2017-12-29T07:37:30.869Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul><li>项目地址：<a href="https://github.com/XndroidDev/Xndroid" target="_blank" rel="noopener">Xndroid</a></li><li>作者：<a href="https://github.com/XndroidDev" target="_blank" rel="noopener">XndroidDev</a></li></ul><h3 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h3><p>首次fork该项目，并进行编译时，编译时不能通过的我用的是最新的Andorid Studio 3.0）——当然有一个原因是我的NDK路径不对，汗~     </p><a id="more"></a><ul><li>首先，直接sync会报错： </li></ul><p><img src="https://raw.githubusercontent.com/Tristan-Hou/MarkdownImg/master/res/xndroid-shrinker-error.jpg" alt=""></p><blockquote><p>Error:Resource shrinker cannot be used for libraries.</p></blockquote><p>原因是library中使用了混淆，并移除了无用的资源文件，解决办法就是把该library中的<code>shrinkResources</code>字段移除——按理说这个字段应该加上，但没想到其他更好的办法，暂时移除吧。 </p><p>接下来应该可以sync成功了。</p><ul><li>随后开始编译，编译失败：</li></ul><p><img src="https://raw.githubusercontent.com/Tristan-Hou/MarkdownImg/master/res/xndroid-compileNdk.jpg" alt=""></p><blockquote><p>:app:ompileDebugNdk</p></blockquote><p>根据提示，我们可以知道这是由于<code>gradle.properties</code>文件中使用了<code>useDeprecatedNdk</code>，而这个东西已经“no longer supported and will removed in the next version”。所以我们有两个解决办法：</p><ol><li>使用<code>CMake</code> 和 <code>ndk-build integration</code>;</li><li>使用<code>android.deprecatedNdkCompileLease=xxx</code>这么一个东西，“for another 60 days”</li></ol><p>我们先实验第二种方法，直接添加“android.deprecatedNdkCompileLease=1511832698813”到gradle.properties文件中，编译成功。</p><p>但是这种方法貌似只能延续60天？那60天后呢？所以为了长久之计，我们还是该使用第一种方法——CMake。</p><hr><p>我是参考这个人的博客<a href="http://blog.csdn.net/qiantanlong/article/details/78622990" target="_blank" rel="noopener">《NDK开发之——Error: Flag android.useDeprecatedNdk is no longer supported爬坑》</a>实现的。具体做法就是：</p><ol><li><p>先将app项目下的<code>build.gradle</code>文件内容按该博客所讲，补齐。</p><pre><code>android {    compileSdkVersion 26    buildToolsVersion &apos;26.0.2&apos;    defaultConfig {        applicationId &quot;net.xndroid&quot;        minSdkVersion 14        targetSdkVersion 26       ndk {          moduleName &quot;sockvpn&quot;  //设置库(so)文件名称          //设置支持的so库架构          abiFilters &quot;armeabi-v7a&quot;, &quot;arm64-v8a&quot;, &quot;armeabi&quot;          ldLibs &quot;log&quot;      }      externalNativeBuild {          cmake {              cppFlags &quot;&quot;          }      }    versionCode 13    versionName &quot;1.1.3-3&quot;    testInstrumentationRunner &quot;android.support.test.runner.AndroidJUnitRunner&quot;    }    buildTypes {        release {            minifyEnabled false            proguardFiles getDefaultProguardFile(&apos;proguard-android.txt&apos;), &apos;proguard-rules.pro&apos;        }    }    sourceSets.main {        jniLibs.srcDirs = [&apos;src/main/jni&apos;]    }    externalNativeBuild {        cmake {            path &quot;CMakeLists.txt&quot;        }    }}</code></pre></li></ol><p>其中<code>moduleName &quot;sockvpn&quot;</code>对应了<code>src/main/jni</code>下的<code>sockvpn</code>文件名，也就是编译出来侯的.so文件名，当然你可以起其他名字。</p><p><code>jniLibs.srcDirs = [&#39;src/main/jni&#39;]</code>是你的jni路径。当然你也看到了，这里还有一个文件<code>CMakeLists.txt</code>，你需要在app项目的根目录创建它。</p><ol><li><p>创建<code>CMakeLists.txt</code>：</p><pre><code># For more information about using CMake with Android Studio, read the# documentation: https://d.android.com/studio/projects/add-native-code.html# Sets the minimum version of CMake required to build the native library.cmake_minimum_required(VERSION 3.4.1)# Creates and names a library, sets it as either STATIC# or SHARED, and provides the relative paths to its source code.# You can define multiple libraries, and CMake builds them for you.# Gradle automatically packages shared libraries with your APK.add_library( # Sets the name of the library.             sockvpn             # Sets the library as a shared library.             SHARED             # Provides a relative path to your source file(s).             src/main/jni/sockvpn.c )# Searches for a specified prebuilt library and stores the path as a# variable. Because CMake includes system libraries in the search path by# default, you only need to specify the name of the public NDK library# you want to add. CMake verifies that the library exists before# completing its build.find_library( # Sets the name of the path variable.              log-lib              # Specifies the name of the NDK library that              # you want CMake to locate.              log )# Specifies libraries CMake should link to your target library. You# can link multiple libraries, such as libraries you define in this# build script, prebuilt third-party libraries, or system libraries.target_link_libraries( # Specifies the target library.                       sockvpn                       # Links the target library to the log library                       # included in the NDK.                       ${log-lib} )</code></pre><p>你只需要将上面博客里所讲的一些模块名字改为<code>sockvpn</code>即可。</p></li></ol><p>至于他说的<code>native-lib.cpp</code>，我们不需要。</p><ol><li>编译，成功。<br><img src="https://raw.githubusercontent.com/Tristan-Hou/MarkdownImg/master/res/xndroid-compile-success.jpg" alt=""></li></ol><p>##总结<br>刚开始接触NDK，很多东西都不懂，因此这么一个小小的编译，都浪费了许多时间。<br>这里所说的<code>CMakeLists.txt</code>内容，我并不能完全懂，还有项目里的<code>Android.mk</code>/<code>Application.mk</code>，我也不是很懂。<br><code>所以说，还是要多学习一个啊！提高姿势水平~</code></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;项目地址：&lt;a href=&quot;https://github.com/XndroidDev/Xndroid&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Xndroid&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;作者：&lt;a href=&quot;https://github.com/XndroidDev&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;XndroidDev&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;编译&quot;&gt;&lt;a href=&quot;#编译&quot; class=&quot;headerlink&quot; title=&quot;编译&quot;&gt;&lt;/a&gt;编译&lt;/h3&gt;&lt;p&gt;首次fork该项目，并进行编译时，编译时不能通过的我用的是最新的Andorid Studio 3.0）——当然有一个原因是我的NDK路径不对，汗~     &lt;/p&gt;
    
    </summary>
    
      <category term="NDK" scheme="http://yoursite.com/categories/NDK/"/>
    
    
      <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
      <category term="NDK" scheme="http://yoursite.com/tags/NDK/"/>
    
  </entry>
  
</feed>
