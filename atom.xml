<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Tristan的博客</title>
  
  <subtitle>Tristan-Hou</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-01-17T16:31:44.258Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Tristan-Hou</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Java类加载器</title>
    <link href="http://yoursite.com/2018/01/14/Java%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8/"/>
    <id>http://yoursite.com/2018/01/14/Java类加载器/</id>
    <published>2018-01-14T15:20:40.609Z</published>
    <updated>2018-01-17T16:31:44.258Z</updated>
    
    <content type="html"><![CDATA[<p>类的数据从class文件加载到内存，并对数据进行<code>校验</code>、<code>解析</code>和<code>初始化</code>，形成可以被虚拟机直接使用的java类型，这就是类加载机制<br><a id="more"></a><br>加载、链接、初始化都在运行期完成，增加了一些内存开销，但是提高了灵活性（面向接口编程，运行时才指定其实际的实现类；本地应用程序从网络流加载一个二进制流程序代码运行）</p><h2 id="类加载时机"><a href="#类加载时机" class="headerlink" title="类加载时机"></a>类加载时机</h2><p>生命周期：</p><div align="center"><br>    <img src="https://raw.githubusercontent.com/Tristan-Hou/MarkdownImg/master/res/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.jpg" width="500" height="200" alt="" align="center"><br></div><p>加载-验证-准备-解析-初始化-使用-卸载，其中验证-准备-解析统称为连接。</p><p>初始化：以下5条被称为类主动引用，会触发初始化（其他任何方式引用类都不会初始化）</p><ul><li>使用new、读取或设置一个累的静态字段、调用一个类静态方法时，会生成<code>new</code>、<code>getstatic</code>、<code>putstatic</code>、<code>invokestatic</code>这四条字节码指令 </li><li>反射</li><li>初始化一个类，先初始化其父类</li><li>虚拟机启动时，会先初始化执行包含<code>main()</code>的那个类</li><li><p>jdk 1.7 动态语言支持，如果java.lang.invoke.MethodHandle实例最后解析结果REF_getstatic、REF_putstatic、REF_invokestatic方法句柄，并且这个方法句柄对应的类没有进行过初始化，需先触发初始化</p><pre><code>//被动使用：子类引用父类静态字段，不会初始化子类public class SuperClass {    static {        System.out.println(&quot;SuperClass init!&quot;);    }    public static int value = 123;}public class SubClass extends SuperClass {    static {        System.out.println(&quot;SubClass init!&quot;);    }}public class NotInitialization {    public static void main(String[] args) {        System.out.println(SubClass.value);    }}//-----------------------------------------------// SuperClass init!</code></pre><p>  静态字段，只有直接定义这个字段的类才会被初始化。</p><pre><code>public class  NotInitialization {    public static void main(String[] args) {        SuperClass[] sca = new SuperClass[10];    }}//-----------------------------------------------// no output.</code></pre><p>  但其实虚拟机为我们创建了一个数组对象[LxxxxSuperClass，并初始化  </p><pre><code>public class ConstClass {    static {        System.out.println(&quot;ConstClass init!&quot;);    }    public static final String HELLOWORLD = &quot;hello world&quot;;}public class  NotInitialization {    public static void main(String[] args) {        System.out.println(ConstClass. HELLOWORLD);    }}//-----------------------------------------------// hello world</code></pre><p> 常量在编译阶段会存入调用累的常量池里。</p></li></ul><h2 id="类加载过程"><a href="#类加载过程" class="headerlink" title="类加载过程"></a>类加载过程</h2><h3 id="加载"><a href="#加载" class="headerlink" title="加载"></a>加载</h3><ol><li>加载阶段，虚拟机需要完成3件事：<ul><li>通过一个类的全限定名来获取定义此类的二进制字节流<ul><li>从zip包读取——JAR、EAR、WAR格式基础</li><li>网络中获取——Applet</li><li>运行时计算生成——动态代理技术，java.lang.reflect.Proxy</li><li>其他文件生成——JSP（JSP文件生成对应的CLass类）</li><li>数据库读取</li></ul></li><li>将这个字节流所代表的静态存储结构转化为方法区运行时数据结构<ul><li>将对象类型信息存储在方法区</li><li>类全限定名</li><li>当前类直接弗雷全限定名</li><li>这个类的接口类型、类类型、枚举类型</li><li>类的访问修饰符信息</li><li>当前类型的超接口全限定名</li><li>当前类型的常量池</li><li>字段信息</li><li>方法信息</li><li>根据以上信息可以创建对象</li></ul></li><li>内存生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口</li></ul></li><li>非数组类可以使用自定义、系统的加载器加载；数组类本身不通过类加载器加载，由虚拟机直接创建</li></ol><h3 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h3><p>连接阶段第一步，确保class文件中字节流包含的信息符合当前虚拟机要求（任何途径都可以生成class文件，并不一定要求用java编译，因此其他语言可能会做到某些java语言做不到的事情，危害虚拟机系统安全）。验证阶段主要完成：</p><ul><li>文件格式验证：字节流符合class文件规范<ul><li>是否以魔数0xCAFFBABE开头</li><li>主、次版本号是否在当前虚拟机处理范围内</li><li>常量池始终是否有不支持类型</li><li>……</li></ul></li><li>元数据验证：对字节码描述的信息进行语义分析，以保证其描述的信息符合Java语言规范的要求<ul><li>是否有父类（除了java.lang.Object，所有类都有父类）</li><li>父类是否继承了不允许继承的类（final修饰）</li><li>是否实现了父类或接口的抽象方法</li><li>类中字段、方法是否与父类冲突矛盾（覆盖父类final字段、重载了方法，但返回值类型不同等）</li></ul></li><li>字节码验证：通过数据流和控制流分析，确定程序语义是合法的、符合逻辑的，主要对类的方法体进行校验分析<ul><li>确保任意时刻操作数栈数据类型与指令代码序列配合工作，不会出现类似操作数栈放了int类型数据，却在使用时按long类型加载</li><li>跳转指令不会跳出方法体外的字节码指令上</li><li>类型转换有效——子类转父类，父类转子类非法等</li></ul></li><li>引用符号验证：确保解析动作能正确执行<ul><li>符号引用中通过字符串描述的全限定名是否能找到对应的类</li><li>指定类中是否存在符合方法的字段描述符以及简单名称所描述的方法和字段</li><li>符号引用中的类、字段、方法的访问性是否可被当前类访问<h3 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h3>准备阶段是为类变量分配内存并设置类变量初始值的阶段，这些变量所使用的内存都将在方法区中进行分配。</li></ul></li></ul><ol><li>这时候进行的内存分配仅包括类变量（static变量），不包括实例变量，实例变量将会在对象实例化时随着对象一起分配在堆中。</li><li><p>这里的初始值<code>通常情况</code>是数据类型的零值：</p><pre><code>public static int value = 123;</code></pre><p>value在准备阶段过后初始值为0，而不是123。此时尚未开始执行任何java方法，只有在初始化阶段，执行虚拟机为static构造的<code>&lt;clinit&gt;()</code>方法后，通过指令<code>putstatic</code>将123赋值给value</p></li><li><p>有“通常情况”，就有<code>特殊情况</code>。如果类字段的字段属性表中存在ConstantValue属性，那么在准备阶段value就会被初始化为指定值：</p><pre><code>public static final int value = 123;</code></pre><p>由于final的修饰，class文件中value会带有ConstantValue属性。</p></li></ol><h3 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h3><p>解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程。解析动作主要针对类或接口、字段、类方法、接口方法、方法类型、方法句柄和调用点限定符7类符号引用进行。</p><ul><li>符号引用：一组符合描述所引用的目标，只要使用时无歧义的定位到目标，可以是任何形式的字面量。引用的目标并不一定已经加载到内存中。</li><li>直接引用：直接指向目标的指针、相对偏移量或一个能简介定位到目标的句柄。如果有了直接引用，那么引用目标一定已经在内存在存在</li></ul><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p>到了初始化阶段，才真正开始执行类中定义的java程序代码。执行类构造器<clinit>()方法，初始化类变量和其他资源。</clinit></p><ol><li><p><clinit>()方法是由编译器自动收集类中的所有类变量的赋值动作和静态语句块static{}中的语句合并产生的，编译器收集的顺序是由语句在源文件中出现的顺序所决定的，静态语句块只能访问到定义在静态语句块之前的变量，定义在它之后的变量，在前面的静态语句块可以赋值，但是不能访问。</clinit></p><pre><code>public class Test {    static {        i=0;        System.out.println(i);//这句编译器会报错：Cannot reference a field before it is defined（非法向前应用）    }    static int i=1;}</code></pre></li><li><p>虚拟机会自动保证优先调用父类的<clinit>()方法，因此弗雷中的静态语句块优先于子类的变量赋值操作</clinit></p><pre><code>static class Parent {    public static int A =1;    static {        A = 2;    }}static class Sub extends Parent {    public static int B = A;}public static void main(String[] args) {    System.out.println(Sub.B);}//-------------------------------------------// 2</code></pre></li><li><p>接口的<clinit>()不需要先执行父类的<clinit>()方法，只有当父接口中定义的变量使用时，父接口才会初始化。接口的实现类在初始化时也一样不会执行接口的<clinit>()</clinit></clinit></clinit></p></li><li><p>虚拟机会保证一个类的<clinit>()方法在多线程环境中被正确的加锁、同步，如果多个线程同时去初始化一个类，那么只会有一个线程去执行这个类的<clinit>()方法，其他线程都需要阻塞等待，直到活动线程执行<clinit>()方法完毕。如果在一个类的<clinit>()方法中有好事很长的操作，就可能造成多个线程阻塞，在实际应用中这种阻塞往往是隐藏的</clinit></clinit></clinit></clinit></p><pre><code>package jvm.classload;public class DealLoopTest{    static class DeadLoopClass{        static{               if(true){                   System.out.println(Thread.currentThread()+&quot;init DeadLoopClass&quot;);               while(true){}        }    }    public static void main(String[] args){        Runnable script = new Runnable(){           public void run(){              System.out.println(Thread.currentThread()+&quot; start&quot;);              DeadLoopClass dlc = new DeadLoopClass();              System.out.println(Thread.currentThread()+&quot; run over&quot;);          }       };       Thread thread1 = new Thread(script);       Thread thread2 = new Thread(script);       thread1.start();       thread2.start();     }}//-----------------------------------------------//Thread[Thread-0,5,main] start//Thread[Thread-1,5,main] start//Thread[Thread-0,5,main]init DeadLoopClass</code></pre><p> 需要注意的是，其他线程虽然会被阻塞，但如果执行<clinit>()方法的那条线程退出<clinit>()方法后，其他线程唤醒之后不会再次进入<clinit>()方法。同一个类加载器下，一个类型只会初始化一次。</clinit></clinit></clinit></p><pre><code>static{    System.out.println(Thread.currentThread() + &quot;init DeadLoopClass&quot;);    try{        TimeUnit.SECONDS.sleep(10);    }catch (InterruptedException e){        e.printStackTrace();    }}//---------------------------------------------//Thread[Thread-0,5,main] start//Thread[Thread-1,5,main] start//Thread[Thread-1,5,main]init DeadLoopClass (之后sleep 10s)//Thread[Thread-1,5,main] run over//Thread[Thread-0,5,main] run over</code></pre></li></ol><h2 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h2><h3 id="类与类加载器"><a href="#类与类加载器" class="headerlink" title="类与类加载器"></a>类与类加载器</h3><p>只有在两个类是由同一个类加载器加载的前提下，才有意义；否则，即使两个类来源于同一个class文件，被同一个虚拟机加载，只要加载它们的类加载器不同，就一定不相等（equals()/isInstance()等）</p><h3 id="双亲委派模型"><a href="#双亲委派模型" class="headerlink" title="双亲委派模型"></a>双亲委派模型</h3><ol><li>三种类加载器：启动类加载器、扩展类加载器、应用程序类加载器</li><li>类加载器先将加载请求委派给父类加载器，只有父类加载器反馈自己无法完成加载请求，才由子类加载器加载</li></ol><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><ul><li><p>一道练习题：</p><pre><code>package jvm.classload;public class StaticTest{    public static void main(String[] args){        staticFunction();    }    static StaticTest st = new StaticTest();    static{        System.out.println(&quot;1&quot;);    }    {        System.out.println(&quot;2&quot;);    }    StaticTest(){        System.out.println(&quot;3&quot;);        System.out.println(&quot;a=&quot;+a+&quot;,b=&quot;+b);    }    public static void staticFunction(){        System.out.println(&quot;4&quot;);    }    int a=110;    static int b =112;}</code></pre></li><li><p>输出是多少？？？</p></li><li><p>先看一个简化代码：</p><pre><code>public class Test {    public static void main(String[] args) {        func();    }    static Test st = new Test();    static void func(){}}  </code></pre><ul><li>main调用，触发静态初始化</li><li>初始化Test静态部分，遇到st成员</li><li>st引用的是本类的实例</li><li>开始实例化st变量（实例初始化嵌入到静态初始化流程中）</li><li>st实例化之后，完成静态初始化剩下的工作</li><li>看起来像是<code>实例初始化出现在了静态初始化之前</code></li></ul></li><li><p>答案：</p><pre><code>23a=110,b=014</code></pre></li><li>why：<ul><li>准备阶段，st=null，b=0；</li><li>初始化阶段：执行构造器。限制性第一条静态语句 st = new StaticTest()，此后进行对象初始化，先初始化成员变量，再执行构造方法。因此，a赋值110，打印2，执行构造方法，打印3，a=110,b=0</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;类的数据从class文件加载到内存，并对数据进行&lt;code&gt;校验&lt;/code&gt;、&lt;code&gt;解析&lt;/code&gt;和&lt;code&gt;初始化&lt;/code&gt;，形成可以被虚拟机直接使用的java类型，这就是类加载机制&lt;br&gt;
    
    </summary>
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
      <category term="Class Loader" scheme="http://yoursite.com/tags/Class-Loader/"/>
    
  </entry>
  
  <entry>
    <title>dex文件结构</title>
    <link href="http://yoursite.com/2018/01/14/dex%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/"/>
    <id>http://yoursite.com/2018/01/14/dex文件结构/</id>
    <published>2018-01-14T11:00:34.208Z</published>
    <updated>2018-01-14T12:22:35.193Z</updated>
    
    <content type="html"><![CDATA[<p>本文主要记录Android中dex文件的结构。</p><a id="more"></a><h2 id="Dex类文件结构"><a href="#Dex类文件结构" class="headerlink" title="Dex类文件结构"></a>Dex类文件结构</h2><h3 id="Dex文件数据项"><a href="#Dex文件数据项" class="headerlink" title="Dex文件数据项"></a>Dex文件数据项</h3><table><thead><tr><th>类型</th><th>含义</th></tr></thead><tbody><tr><td>U1</td><td>等同于uint8_t，1字节</td></tr><tr><td>U2</td><td>unint16_t，2字节</td></tr><tr><td>U4</td><td>uint32_t，4字节</td></tr><tr><td>U8</td><td>uint64_t，8字节</td></tr><tr><td>sleb128</td><td>有符号LEB128，可变长度1~5字节</td></tr><tr><td>uleb128</td><td>无符号LEB128，可变长度1~5字节</td></tr><tr><td>uleb128p1</td><td>无符号LEB128+1，可变长度1~5字节</td></tr></tbody></table><p>leb128:</p><table cellspacing="3px"><br>    <tr><br>        <td colspan="16" align="center">Two-byte of LEB128 value</td><br>    </tr><br>    <tr><br>        <td colspan="8" align="center">First byte</td><br>        <td colspan="8" align="center">Second byte</td><br>    </tr><br>    <tr><br>        <td>1</td><br>        <td>bit6</td><br>        <td>bit5</td><br>        <td>bit4</td><br>        <td>bit3</td><br>        <td>bit2</td><br>        <td>bit1</td><br>        <td>bit0</td><br>        <td>0</td><br>        <td>bit13</td><br>        <td>bit12</td><br>        <td>bit11</td><br>        <td>bit10</td><br>        <td>bit9</td><br>        <td>bit8</td><br>        <td>bit7</td><br>    </tr><br></table><p>最长35位，可表示32位数据，大多数情况下数据值都很小，因此小于4字节空间，节约空间。</p><p>|dex header |</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文主要记录Android中dex文件的结构。&lt;/p&gt;
    
    </summary>
    
      <category term="虚拟机" scheme="http://yoursite.com/categories/%E8%99%9A%E6%8B%9F%E6%9C%BA/"/>
    
    
      <category term="虚拟机" scheme="http://yoursite.com/tags/%E8%99%9A%E6%8B%9F%E6%9C%BA/"/>
    
  </entry>
  
  <entry>
    <title>Java类文件结构</title>
    <link href="http://yoursite.com/2018/01/09/Java%E7%B1%BB%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/"/>
    <id>http://yoursite.com/2018/01/09/Java类文件结构/</id>
    <published>2018-01-09T15:15:35.481Z</published>
    <updated>2018-01-14T11:02:09.644Z</updated>
    
    <content type="html"><![CDATA[<p>本文主要记录Java中Class文件的结构。</p><a id="more"></a><h2 id="Java类文件结构"><a href="#Java类文件结构" class="headerlink" title="Java类文件结构"></a>Java类文件结构</h2><p>以8位字节为基础单位的二进制流，超过8字节的数据结构，高位在前低位在后进行分割</p><h3 id="class文件中的数据项："><a href="#class文件中的数据项：" class="headerlink" title="class文件中的数据项："></a>class文件中的数据项：</h3><table><thead><tr><th>类型</th><th>名称</th><th>数量</th></tr></thead><tbody><tr><td>u4</td><td>magic</td><td>1</td></tr><tr><td>u2</td><td>minor_version</td><td>1</td></tr><tr><td>u2</td><td>major_version</td><td>1</td></tr><tr><td>u2</td><td>constant_ pool_count</td><td>1</td></tr><tr><td>cp_info</td><td>constant_pool</td><td>constant_ pool_count - 1</td></tr><tr><td>u2</td><td>access_flags</td><td>1</td></tr><tr><td>u2</td><td>this_class</td><td>1</td></tr><tr><td>u2</td><td>super_class</td><td>1</td></tr><tr><td>u2</td><td>interfaces_count</td><td>1</td></tr><tr><td>u2</td><td>interfaces</td><td>interfaces_count</td></tr><tr><td>u2</td><td>fields_count</td><td>1</td></tr><tr><td>field_info</td><td>fields</td><td>fields_count</td></tr><tr><td>u2</td><td>methods_count</td><td>1</td></tr><tr><td>method_info</td><td>methods</td><td>methods_count</td></tr><tr><td>u2</td><td>attribute_count</td><td>1</td></tr><tr><td>attribute_info</td><td>attributes</td><td>attributes_count</td></tr></tbody></table><p>u1、u2、u4、u8分别代表1、2、4、8个字节</p><div align="left"><br>  <img src="https://raw.githubusercontent.com/Tristan-Hou/MarkdownImg/master/res/class%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84.png" width="500" height="500" alt="" aligh="center/"><br>   </div><h3 id="魔数：magic"><a href="#魔数：magic" class="headerlink" title="魔数：magic"></a>魔数：magic</h3><p>4个字节，代表class文件，固定值为0xCAFFBABE。如果不是这个值，文件不能被JVM识别</p><h3 id="版本号：minor-major-version"><a href="#版本号：minor-major-version" class="headerlink" title="版本号：minor/major_version"></a>版本号：minor/major_version</h3><p>2个字节，次/主版本号</p><h3 id="常量池："><a href="#常量池：" class="headerlink" title="常量池："></a>常量池：</h3><p>先以2字节的容量计数值constant_pool_count存储常量池中常量数量；常量池存放字符串、final常量值、当前类类名、字段名、方法名、字段和方法的描述符，当前类字段和方法引用信息等</p><ol><li>常量池中索引项从1开始，引用0的地方代表此处不引用任何常量池项</li><li>常量池存两类常量：字面量、符号引用</li><li><p>符号引用：</p><ul><li>类、接口全限定名：类似于java/lang/Object，用/不用.（java.lang.Object）</li><li><p>字段名称和描述符：所有的类型在描述符中都有对应的字符或字符串来对应。   </p><p>| 类型 | 对应字符或字符串 | 例子 |<br>|— | — |—|<br>|byte | B |—|<br>|char | C |—|<br>|double | D |—|<br>|float | F |—|<br>|int | I |—|<br>|long | J |—|<br>|short | S |—|<br>|boolean | Z |—|<br>|void | V |—|<br>|类、接口、枚举 | “L”+全限定名+“;” | Ljava/lang/Object;|<br>|数组 | n个“[”+元素类型字符/串| [[[Ljava/lang/Object; |<br>  float和boolean对应的不是F和B，历史原因。</p></li><li><p>方法名称和描述符：所有参数的类型列表和方法返回值——<code>(参数1类型参数2类型参数3类型 ...)返回值类型</code> 各个参数之间无空格</p><p>  | 方法描述符 | 方法声明 |<br>  |— | — |<br>  |()I | int getSize()|<br>  |()Ljava/lang/String;|String toString()|<br>  |([Ljava/lang/String;)V|void main(String[] args)|<br>  | …. |<br>  |([BII)I | int read(byte[] b, int offm int len)|<br>  |()[[Ljava/lang/Object; | Object[][] getObjectArray() |</p></li><li><p>java没有<code>连接</code>步骤，是在需要一个class时候，由classloader加载class文件进行动态连接，从常量池里获取符号引用，创建类时解析、翻译到具体内存地址中。否则无法找到字段、方法对应的内存入口地址，无法被虚拟机使用</p></li></ul></li></ol><h4 id="常量池数据项："><a href="#常量池数据项：" class="headerlink" title="常量池数据项："></a>常量池数据项：</h4><table><thead><tr><th>数据项类型</th><th>类型标志</th><th>描述</th></tr></thead><tbody><tr><td>CONSTANT_ Utf8_info</td><td>1</td><td>UTF-8编码的字符串</td></tr><tr><td>CONSTANT_ Integer_info</td><td>3</td><td>int类型字面值</td></tr><tr><td>CONSTANT_ Float_info</td><td>4</td><td>float类型字面值</td></tr><tr><td>CONSTANT_ Long_info</td><td>5</td><td>long类型字面值</td></tr><tr><td>CONSTANT_ Double_info</td><td>6</td><td>double类型字面值</td></tr><tr><td>CONSTANT_ Class_info</td><td>7</td><td>对一个类或接口的符号引用</td></tr><tr><td>CONSTANT_ String_info</td><td>8</td><td>String类型字面值</td></tr><tr><td>CONSTANT_ Fieldref_info</td><td>9</td><td>对一个字段的符号引用</td></tr><tr><td>CONSTANT_ Methodref_info</td><td>10</td><td>对一个类中声明的方法的符号引用</td></tr><tr><td>CONSTANT_ InterfaceMethodref_info</td><td>11</td><td>对一个接口中声明的方法的符号引用</td></tr><tr><td>CONSTANT_ NameAndType_info</td><td>12</td><td>对一个字段或方法的部分符号引用</td></tr></tbody></table><ul><li>每个类型中都有一个tag，位于数据项第一个字节，值为上表的“类型标志”</li></ul><h4 id="CONSTANT-Utf8-info"><a href="#CONSTANT-Utf8-info" class="headerlink" title="CONSTANT_Utf8_info"></a><code>CONSTANT_Utf8_info</code></h4><p>最基础的数据项，存储一个常量池字符串。</p><ul><li>常量池中所有的<code>字面量</code>几乎都是通过这个类型描述的，其他类型的常量池项只不过是对CONSTANT_Utf8_info的引用</li><li>首位tag值为1，随后2个字节是字符串长度length，接下来是字符串的存储值:</li></ul><div align="center"><br>  <img src="https://raw.githubusercontent.com/Tristan-Hou/MarkdownImg/master/res/CONSTANT_Utf8_info%E7%BB%93%E6%9E%84%E5%9B%BE.jpg" width="200" height="200" alt="CONSTANT_Utf8_info格式" align="center"><br>  </div><p>  因为class中文件中方法、字段都要引用CONSTANT<em> Utf8</em> info，因此此类型最大长度就是java中方法、字段名称的最大长度——即：2的16次方65535，如果方法名、变量名超过该值，就无法编译<br>  如果存储的String为Hello：</p>   <div align="center"><br>   <img src="https://raw.githubusercontent.com/Tristan-Hou/MarkdownImg/master/res/CONSTANT_Utf8_info%E7%BB%93%E6%9E%84%E4%BE%8B%E5%AD%90.jpg" width="200" height="200" alt="" aligh="center/"><br>   </div><ul><li>可包括的字符串：<ul><li>字符串常量：“Hello”等</li><li>全限定名：当前类、接口、枚举、直接弗雷、实现或继承的接口、引用的类型</li><li>方法、字段名称：本类的、引用的</li><li>方法、字段描述符：本类的、引用的</li><li>当前class文件中属性相关字符串：属性信息attribute</li></ul></li><li><p>更具体的例子：</p><pre><code>package com.jg.zhang;public class Programer extends Person {    static String company = &quot;CompanyA&quot;;    static{        System.out.println(&quot;staitc init&quot;);    }    String position;    Computer computer;    public Programer() {        this.position = &quot;engineer&quot;;        this.computer = new Computer();    }    public void working(){        System.out.println(&quot;coding...&quot;);        computer.working();    }} </code></pre><p> 反编译后取出CONSTANT_ Utf8_info相关数据项：</p><pre><code>#2 = Utf8      com/jg/zhang/Programer     //当前类的全限定名 #4 = Utf8      com/jg/zhang/Person        //父类的全限定名  #5 = Utf8      company                    //company字段的名称  #6 = Utf8      Ljava/lang/String;         //company和position字段的描述符  #7 = Utf8      position                   //position字段的名称  #8 = Utf8      computer                   //computer字段的名称  #9 = Utf8      Lcom/jg/zhang/Computer;    //computer字段的描述符  #10 = Utf8     &lt;clinit&gt;                   //类初始化方法（即静态初始化块）的方法名  #11 = Utf8     ()V                        //working方法的描述符  #12 = Utf8     Code                       //Code属性的属性名  #14 = Utf8     CompanyA                   //程序中的常量字符串  #19 = Utf8     java/lang/System           //所引用的System类的全限定名  #21 = Utf8     out                        //所引用的out字段的字段名  #22 = Utf8     Ljava/io/PrintStream;      //所引用的out字段的描述符  #24 = Utf8     staitc init                //程序中的常量字符串  #27 = Utf8     java/io/PrintStream        //所引用的PrintStream类的全限定名  #29 = Utf8     println                    //所引用的println方法的方法名  #30 = Utf8     (Ljava/lang/String;)V      //所引用的println方法的描述符  #31 = Utf8     LineNumberTable            //LineNumberTable属性的属性名  #32 = Utf8     LocalVariableTable         //LocalVariableTable属性的属性名  #33 = Utf8     &lt;init&gt;                     //当前类的构造方法的方法名  #41 = Utf8     com/jg/zhang/Computer      //所引用的Computer类的全限定名  #45 = Utf8     this                       //局部变量this的变量名  #46 = Utf8     Lcom/jg/zhang/Programer;   //局部变量this的描述符  #47 = Utf8     working                    //woking方法的方法名  #49 = Utf8     coding...                  //程序中的字符串常量  #52 = Utf8     SourceFile                 //SourceFile属性的属性名  #53 = Utf8     Programer.java             //当前类所在的源文件的文件名</code></pre></li></ul><h4 id="CONSTANT-NameAndType"><a href="#CONSTANT-NameAndType" class="headerlink" title="CONSTANT_NameAndType"></a><code>CONSTANT_NameAndType</code></h4><p>字段名称-字段描述符/方法名称-方法描述符</p><ul><li><p>首位tag为12，随后两个字节name<em>index，指向常量池中一个CONSTANT</em> Utf8_info，存储方法/字段名称，接下来两个字节descriptor<em>index指向一个CONSTANT</em> Utf8_info，存储方法/字段描述符</p><div align="center"><br><img src="https://raw.githubusercontent.com/Tristan-Hou/MarkdownImg/master/res/CONSTANT_NameAndType%E7%BB%93%E6%9E%84%E5%9B%BE.jpg" width="170" height="180" alt="" aligh="center/"><br></div></li><li><p>具体的例子:</p><pre><code>package com.jg.zhang;public class Person {    int age;    int getAge(){        return age;    }} </code></pre><p>  javap反编译:</p><pre><code>#1 = Class         #2         //  com/jg/zhang/Person  #2 = Utf8          com/jg/zhang/Person  #3 = Class         #4         //  java/lang/Object #4 = Utf8          java/lang/Object  #5 = Utf8          age  #6 = Utf8          I  #7 = Utf8          &lt;init&gt;  #8 = Utf8          ()V  #9 = Utf8          Code  #10 = Methodref    #3.#11     //  java/lang/Object.&quot;&lt;init&gt;&quot;:()V  #11 = NameAndType  #7:#8      //  &quot;&lt;init&gt;&quot;:()V  #12 = Utf8         LineNumberTable  #13 = Utf8         LocalVariableTable  #14 = Utf8         this  #15 = Utf8         Lcom/jg/zhang/Person; #16 = Utf8         getAge  #17 = Utf8         ()I  #18 = Fieldref     #1.#19     //  com/jg/zhang/Person.age:I  #19 = NameAndType  #5:#6      //  age:I  #20 = Utf8         SourceFile  #21 = Utf8         Person.java</code></pre><ul><li>第#11和#19是CONSTANT_NameAndType，#11引用了#7和#8，#19引用了#5和#6</li><li>第#7和#8是CONSTANT_Utf8_info，值为<init>和()V</init></li><li>CONSTANT_ NameAndType是对一个字段或方法的部分符号引用，换句话说，它应该指向一个被引用的字段或方法。如果类中定义了一个字段或方法，但是没有在别处被引用，那么常量池中是不会有相应的CONSTANT_NameAndType的</li><li>源码中有getAge()和编译器添加的构造函数两个方法，因为没有在别处调用，所有不存在相对应的CONSTANT_NameAndType</li><li>第#7和#8处的<init>、()V是父类Object的构造方法，因为子类的构造方法默认调用父类无参构造方法</init></li><li>第#5和#6存储age和I，描述了源码中的age字段。</li><li>在getAge()中引用了age，所有存在对应的CONSTANT_NameAndType</li></ul><div align="center"><br><img src="https://raw.githubusercontent.com/Tristan-Hou/MarkdownImg/master/res/Object%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%92%8CCONSTANT_NameAndType_info.jpg" width="400" height="400" alt="" aligh="center/"><br></div><div align="center"><br><img src="https://raw.githubusercontent.com/Tristan-Hou/MarkdownImg/master/res/age%E5%AD%97%E6%AE%B5%E5%92%8CCONSTANT_NameAndType_info.jpg" width="400" height="400" alt="" aligh="center/"><br></div></li></ul><h4 id="CONSTANT-Integer-info"><a href="#CONSTANT-Integer-info" class="headerlink" title="CONSTANT_Integer_info"></a><code>CONSTANT_Integer_info</code></h4><ul><li>首位tag为3，接下来4个字节bytes，存储int</li><li><p>示例代码：</p><pre><code>void printInt(){      System.out.println(65535);  }</code></pre><p>反编译：</p><pre><code>Constant pool:...#21 = Integer      65535...{...    void printInt();    flags:    Code:        stack=2, locals=1, args_size=1            0: getstatic    #15   // Field java/lang/System.out:Ljava/io/PrintStream;             3: ldc      #21   // int 65535            5: invokevirtual    #22   // Method java/io/PrintStream.println:(I)V            8: return        LineNumberTable:            line 6: 0            line 7: 8        LocalVariableTable:              Start  Length  Slot  Name   Signature               0       9     0    this   Lcom/jg/zhang/TestInt;   }  </code></pre><p><code>3: Idc #21</code>：Idc引用了第#21项，为65535</p></li></ul><h4 id="CONSTANT-Float-info"><a href="#CONSTANT-Float-info" class="headerlink" title="CONSTANT_Float_info"></a><code>CONSTANT_Float_info</code></h4><p>与CONSTANT_Integer_info类似，tag值为4，存储float类型值，4字节</p><h4 id="CONSTANT-Long-info"><a href="#CONSTANT-Long-info" class="headerlink" title="CONSTANT_Long_info"></a><code>CONSTANT_Long_info</code></h4><p>与CONSTANT_Integer_info类似，tag值为5，存储long类型值，8字节</p><h4 id="CONSTANT-Double-info"><a href="#CONSTANT-Double-info" class="headerlink" title="CONSTANT_Double_info"></a><code>CONSTANT_Double_info</code></h4><p>与CONSTANT_Integer_info类似，tag值为6，存储double类型值，8字节</p><h4 id="CONSTANT-String-info"><a href="#CONSTANT-String-info" class="headerlink" title="CONSTANT_String_info"></a><code>CONSTANT_String_info</code></h4><p>tag值为8，随后2个字节string_index是常量池引用，指向一个CONSTANT_Utf8_info，存放字符串</p><ul><li><p>代码：</p><pre><code>void printStrng(){      System.out.println(&quot;abcdef&quot;);   }</code></pre><p>反编译：</p><pre><code>Constant pool:...#21 = String     #22      //  abcdef  #22 = Utf8       abcdef ...{    void printStrng();        flags:        Code:             stack=2, locals=1, args_size=1                 0: getstatic     #15     // Field java/lang/System.out:Ljava/io/PrintStream;                 3: ldc           #21     // String abcdef                   5: invokevirtual #23     // Method java/io/PrintStream.println:(Ljava/lang/String;)V                  8: return             LineNumberTable:                 line 7: 0                  line 8: 8              LocalVariableTable:                  Start  Length  Slot  Name   Signature                   0      9      0   this   Lcom/jg/zhang/TestInt;}</code></pre><p> Idc指向#21，#21为CONSTANT_String_info，它又指向#22，#22是一个CONSTANT_Utf8_info，存储abcdef</p> <div align="center"><br><img src="https://raw.githubusercontent.com/Tristan-Hou/MarkdownImg/master/res/abcde%E5%92%8CCONSTANT_String_info.png" width="400" height="400" alt="" aligh="center/"><br></div></li></ul><h4 id="CONSTANT-Class-info"><a href="#CONSTANT-Class-info" class="headerlink" title="CONSTANT_Class_info"></a><code>CONSTANT_Class_info</code></h4><p>对类或者接口的符号引用。当前类信息，当前类引用，其他类引用</p><ul><li>tag值为7，随后2字节name_index指向一个CONSTANT_Utf8_info，存储类的全限定名或数组的描述符字符串<ul><li>Object类型：java/lang/Object </li><li>Object[]类型：[Ljava/lang/Object;</li></ul></li><li><p>结构图:</p><div align="center"><br><img src="https://raw.githubusercontent.com/Tristan-Hou/MarkdownImg/master/res/CONSTANT_Class_info%E5%AD%98%E5%82%A8%E5%B8%83%E5%B1%80.jpg" width="400" height="400" alt="" aligh="center/"><br></div></li><li><p>在一个类中引用了System这个类,常量池:</p><pre><code>Constant pool:    #16 = Class     #17    // java/lang/System    #17 = Utf8      java/lang/System</code></pre></li></ul><h4 id="CONSTANT-Fieldref-info"><a href="#CONSTANT-Fieldref-info" class="headerlink" title="CONSTANT_Fieldref_info"></a><code>CONSTANT_Fieldref_info</code></h4><p>对一个字段的符号引用。当前类中字段、其他类中字段、成员变量字段、静态变量字段</p><ul><li>tag值为9，随后2个字节class<em> index指向CONSTANT</em> Class<em> info，表示被引用的字段的类型、接口，接下来2字节name</em> and<em> type</em> index指向CONSTANT<em> NameAndType</em> info，表示被引用的字段的名称和描述符</li><li><p>代码：</p><pre><code>package com.jg.zhang;public class TestInt {   int a = 10;   void print(){       System.out.println(a);   }}</code></pre><p> 反编译：</p><pre><code>Constant pool:#1 = Class      #2        //  com/jg/zhang/TestInt#2 = Utf8       com/jg/zhang/TestInt...#5 = Utf8       a#6 = Utf8       I...#12 = Fieldref       #1.#13       //  com/jg/zhang/TestInt.a:I#13 = NameAndType      #5:#6        //  a:I ...{    void print();        flags:        Code:            stack=2, locals=1, args_size=1                0: getstatic     #19     // Field java/lang/System.out:Ljava/io/PrintStream;                  3: aload_0                4: getfield      #12     // Field a:I                  7: invokevirtual #25     // Method java/io/PrintStream.println:(I)V                10: return  } </code></pre><div align="center"><br><img src="https://raw.githubusercontent.com/Tristan-Hou/MarkdownImg/master/res/CONSTANT_Fieldref_info%E7%BB%93%E6%9E%84.jpg" width="600" height="500" alt="" aligh="center/"><br></div>  </li></ul><h4 id="CONSTANT-Methodref-info"><a href="#CONSTANT-Methodref-info" class="headerlink" title="CONSTANT_Methodref_info"></a><code>CONSTANT_Methodref_info</code></h4><p>对一个类中方法的符号引用。本类或其他类，成员方法、静态方法均可，但不会是对接口中的方法的符号引用。类似CONSTANT<em> Fieldref</em> info</p><ul><li>tag为10，2字节class<em> index指向CONSTANT</em> Class<em> info，表示被引用的方法所在的类型，2字节name</em> and<em> type</em> index指向CONSTANT<em> NameAndType</em> info，代表被引用的方法的名称和描述符</li><li><p>代码：</p><pre><code>//程序1package com.jg.zhang;public class Programer {    Computer computer;    public Programer(Computer computer){        this.computer = computer;    }      public void doWork(){        computer.calculate();     }  }//程序2package com.jg.zhang; public class Computer {      public void calculate() {         System.out.println(&quot;working...&quot;);      }  } </code></pre><p> 程序1调用了程序2，只反编译程序1：</p><pre><code>Constant pool:...#12 = Utf8     ()V...#20 = Methodref      #21.#23      //  com/jg/zhang/Computer.calculate:()V #21 = Class          #22          //  com/jg/zhang/Computer#22 = Utf8           com/jg/zhang/Computer#23 = NameAndType    #24:#12      //  calculate:()V#24 = Utf8           calculate...{    com.jg.zhang.Computer computer;        flags:       ...       public void doWork();           flags: ACC_PUBLIC             Code:                 stack=1, locals=1, args_size=1                     0: aload_0                     1: getfield      #13      // Field computer:Lcom/jg/zhang/Computer;                     4: invokevirtual #20      // Method com/jg/zhang/Computer.calculate:()V                     7: return }</code></pre><div align="center"><br><img src="https://raw.githubusercontent.com/Tristan-Hou/MarkdownImg/master/res/CONSTANT_Methodref_info%E7%BB%93%E6%9E%84%E5%9B%BE.jpg" width="600" height="500" alt="" aligh="center/"><br></div> </li></ul><h4 id="CONSTANT-InterfaceMethodref-info"><a href="#CONSTANT-InterfaceMethodref-info" class="headerlink" title="CONSTANT_InterfaceMethodref_info"></a><code>CONSTANT_InterfaceMethodref_info</code></h4><p>表示对一个接口方法的符号引用，不表示类中的方法。</p><ul><li>tag为11，2个字节的class<em>index指向CONSTANT</em> Class<em> info，表示被引用的而方法所在的接口，2字节name</em> and<em> type</em> index指向CONSTANT<em> NameAndType</em> info，被引用方法的名称和描述符。</li><li><p>代码：</p><pre><code>package com.jg.zhang;     public class Plane {        IFlyable flyable;     void flyToSky(){          flyable.fly();      }  }  ...package com.jg.zhang; public interface IFlyable {      void fly();  } </code></pre><p>反编译：</p><pre><code>Constant pool:...#8 = Utf8                ()V  ...#19 = InterfaceMethodref #20.#22     //  com/jg/zhang/IFlyable.fly:()V  #20 = Class              #21         //  com/jg/zhang/IFlyable  #21 = Utf8               com/jg/zhang/IFlyable  #22 = NameAndType        #23:#8      //  fly:()V  #23 = Utf8               fly {    com.jg.zhang.IFlyable flyable;         flags:       ...    void flyToSky();         flags:         Code:            stack=1, locals=1, args_size=1               0: aload_0               1: getfield    #17    // Field flyable:Lcom/jg/zhang/IFlyable;               4: invokeinterface   #19, 1    // InterfaceMethod com/jg/zhang/IFlyable.fly:()V               9: return }   </code></pre><div align="center"><br><img src="https://raw.githubusercontent.com/Tristan-Hou/MarkdownImg/master/res/CONSTANT_InterfaceMethodref_info%E7%BB%93%E6%9E%84%E5%9B%BE.jpg" width="600" height="500" alt="" aligh="center/"><br></div>  </li></ul><h3 id="访问标志"><a href="#访问标志" class="headerlink" title="访问标志"></a>访问标志</h3><p>access_flags：描述当前类或接口的访问修饰符，public、private等。同时有一个标志位记录这个class是类还是接口。</p><table><thead><tr><th>表知名</th><th>标志值</th><th>含义</th><th>针对的对象</th></tr></thead><tbody><tr><td>ACC_PUBLIC</td><td>0x0001</td><td>public类型</td><td>所有类型</td></tr><tr><td>ACC_FINAL</td><td>0x0010</td><td>final类型</td><td>类</td></tr><tr><td>ACC_SUPER</td><td>0x0020</td><td>使用新的invokespecial语义</td><td>类和接口</td></tr><tr><td>ACC_INTERFACE</td><td>0x0200</td><td>接口类型</td><td>接口</td></tr><tr><td>ACC_ABSTRACT</td><td>0x0400</td><td>抽象类型</td><td>类和接口</td></tr><tr><td>ACC_SYNTHETIC</td><td>0x1000</td><td>该类不由用户代码生成</td><td>所有类型</td></tr><tr><td>ACC_ANNOTATION</td><td>0x2000</td><td>注解类型</td><td>注解</td></tr><tr><td>ACC_ENUM</td><td>0x4000</td><td>枚举类型</td><td>枚举</td></tr></tbody></table><p>access_flags只能描述类、接口，不能描述字段或方法的修饰符</p><h3 id="类索引"><a href="#类索引" class="headerlink" title="类索引"></a>类索引</h3><p>this<em> class：2字节，对当前类的描述，指向一个CONSTANT</em> Class_ info，存放着当前类的全限定名</p><ul><li><p>代码：</p><p>   package com.jg.zhang;<br>   public class Person { </p><pre><code>int age;  int getAge(){      return age;  }  </code></pre><p>   }<br>反编译：</p><pre><code>Constant pool:  #1 = Class     #2     //  com/jg/zhang/Person  #2 = Utf8      com/jg/zhang/Person</code></pre></li></ul><h3 id="父类索引"><a href="#父类索引" class="headerlink" title="父类索引"></a>父类索引</h3><p>super<em> class：描述的是当前类的超类的信息，指向一个CONSTANT</em> Class_ info，存放着当前类的超类的全限定名（如果直接继承Object，那么super<em>class的索引值为0，也可以视为这个索引不引用任何常量池中的数据项）。其他类似this</em> class</p><h3 id="接口索引集合"><a href="#接口索引集合" class="headerlink" title="接口索引集合"></a>接口索引集合</h3><ul><li><p>interfaces_ count：当前类所实现的接口的数量或当前接口所继承的超接口数量（只有当前类直接实现的接口才会被统计， 如果当前类继承了另一个类， 而另一个类又实现了一个接口， 那么这个接口不会统计在当前类的interfaces_count中）</p></li><li><p>interfaces：共有interfaces<em> count个，指向CONSTANT</em> Class_ info，带表当前类直接实现、继承的接口的全限定名</p></li></ul><h3 id="字段表集合"><a href="#字段表集合" class="headerlink" title="字段表集合"></a>字段表集合</h3><ul><li>fields_count：当前类中定义的字段的个数，包括静态字段，但不包括从父类集成的字段<ul><li>编译器可能会自动添加某些字段，比如内部类拥有外部类的对象引用，所以class文件中字段数量可能多于源文件定义的数量</li></ul></li><li><p>fields：共有fields_count个，每个都是一个field_info</p><ul><li>field_info结构：</li></ul><div align="center"><br><img src="https://raw.githubusercontent.com/Tristan-Hou/MarkdownImg/master/res/field_info%E6%8F%8F%E8%BF%B0.jpg" width="150" height="160" alt="" aligh="center/"><br> </div> <ul><li>access_flags：2字节</li></ul><p>| 标志位名称 | 值 |含义 |设定者|<br>|—-|—-|—-|—-|<br>| ACC_PUBLIC | 0x0001 | 字段被设为public | 类和接口 |<br>| ACC_PRIVATE | 0x0002 | 字段被设为private | 类 |<br>| ACC_PROTECTED | 0x0004 | 字段被设为protected | 类 |<br>| ACC_STATIC | 0x0008 | 字段被设为static | 类和接口 |<br>| ACC_FINAL | 0x0010 | 字段被设为final | 类和接口 |<br>| ACC_VOLATILE | 0x0040 | 字段被设为volatile | 类 |<br>| ACC_TRANSIENT | 0x0080 | 字段被设为transient | 类 |</p><ul><li>name<em>index：2字节，指向常量池索引CONSTANT</em> Utf8_i nfo，描述当前字段名。</li><li>descriptor<em>index：2字节，指向常量池索引CONSTANT</em> Utf8_i nfo，描述当前字段描述符。</li><li>attribute_count：属性个数</li><li>attributes：属性信息，attribute_count个属性attribute_info。共有三种属性：ConstantValue， Deprecated， 和 Synthetic</li><li><p>代码：</p><pre><code>package com.jg.zhang; public class Programer extends Person{     private Computer computer;      public Programer(Computer computer){          this.computer = computer;      }      public void doWork(){         computer.calculate();      }  } </code></pre><p> 反编译：</p><pre><code>Constant pool: ...#5 = Utf8     computer  #6 = Utf8     Lcom/jg/zhang/Computer;...   {     private com.jg.zhang.Computer computer;      flags: ACC_PRIVATE}</code></pre></li></ul></li></ul><h3 id="方法表集合"><a href="#方法表集合" class="headerlink" title="方法表集合"></a>方法表集合</h3><ul><li>methods_count：当前的类中定义的方法的个数，包括静态方法，不包括父类继承的方法<ul><li>编译器会增加某些方法，例如<init>或<clinit>，因此可能或多于源文件方法数</clinit></init></li></ul></li><li><p>methods：共有methods_count个，每个都是一个method_info</p><ul><li><p>method_info结构：</p><div align="center"><br><img src="https://raw.githubusercontent.com/Tristan-Hou/MarkdownImg/master/res/method_info%E7%BB%93%E6%9E%84.jpg" width="150" height="160" alt="" aligh="center/"><br></div> </li><li><p>access_flags: 类似field_info，多了ACC_SYNCHRONIZED、ACC_NATIVE、ACC_ABSTRACT、ACC_STRICT</p></li><li>name_index：当前方法的方法名</li><li>descriptor_index：当前方法的描述符</li><li>attribute_count：属性个数</li><li>attributes：属性信息，attribute_count个属性attribute_info。有Code， Deprecated， Exceptions 和Synthetic</li></ul></li></ul><div align="center"><br>  <img src="https://raw.githubusercontent.com/Tristan-Hou/MarkdownImg/master/res/methods%E5%BC%95%E7%94%A8%E7%BB%93%E6%9E%84.jpg" width="600" height="500" alt="" aligh="center/"><br>   </div> <h3 id="属性表集合"><a href="#属性表集合" class="headerlink" title="属性表集合"></a>属性表集合</h3><ul><li>attributes_count：2字节，class文件中属性个数</li><li><p>attributes：attributes_count个，每一个都是一个attribute_info。在class文件顶层、field_info、method_info都会出现</p><ul><li>结构：</li></ul><div align="center"><br><img src="https://raw.githubusercontent.com/Tristan-Hou/MarkdownImg/master/res/attribute%E7%BB%93%E6%9E%84.jpg" width="130" height="100" alt="" aligh="center/"><br> </div> <ul><li>attribute_name_index：2字节，指向CONSTANT_Utf8_info，存放当前属性的名字</li><li>attribute_length：当前属性的长度</li><li>info：真实的属性数据</li></ul></li></ul><h4 id="几个重要的属性"><a href="#几个重要的属性" class="headerlink" title="几个重要的属性"></a>几个重要的属性</h4><h5 id="SourceFile属性："><a href="#SourceFile属性：" class="headerlink" title="SourceFile属性："></a>SourceFile属性：</h5><ul><li>顶层class文件中出现，描述了该类是从哪个源文件中编译来的，一个源文件中可以存在多个类</li></ul><div align="center"><br>  <img src="https://raw.githubusercontent.com/Tristan-Hou/MarkdownImg/master/res/SourceFile.jpg" width="200" height="180" alt="" aligh="center/"><br>   </div> <ul><li>attribute_name_index：“SourceFile”字符串</li><li>attribute_length：长度，2</li><li>sourcefile_index：指向CONSTANT_Utf8_info，生成该类的源文件的文件名，没有路径</li><li><p>代码：</p><pre><code>package com.jg.zhang;  public class Person {      int age;      int getAge(){          return age;      }  } </code></pre><p>反编译：</p><pre><code>public class com.jg.zhang.Person      SourceFile: &quot;Person.java&quot;  Constant pool:  ...      #20 = Utf8               SourceFile      #21 = Utf8               Person.java  ...</code></pre></li></ul><div align="center"><br>  <img src="https://raw.githubusercontent.com/Tristan-Hou/MarkdownImg/master/res/SourceFile%E5%B1%9E%E6%80%A7%E5%BC%95%E7%94%A8.jpg" width="600" height="500" alt="" aligh="center/"><br>   </div> <h5 id="InnerClasses属性"><a href="#InnerClasses属性" class="headerlink" title="InnerClasses属性"></a>InnerClasses属性</h5><p>顶层class文件中出现，描述的是内部类和外围类的关系.每个类可能有多个内部类， 而这些内部类中可能还有内部类， 多层嵌套。外围类中的InnerClasses属性必须描述它的所有内部类， 而内部类中的InnerClasses也必须描述它的外围类</p><h5 id="Synthetic属性"><a href="#Synthetic属性" class="headerlink" title="Synthetic属性"></a>Synthetic属性</h5><p>可以出现在filed_info、method_info和顶层的ClassFile中。表示这个字段， 方法或类是由编译器自动添加的，不是程序员写的，没有源文件（内部类对外部类的引用，构造方法等）</p>  <div align="center"><br>  <img src="https://raw.githubusercontent.com/Tristan-Hou/MarkdownImg/master/res/Synthetic.jpg" width="200" height="180" alt="" aligh="center/"><br>  </div><h5 id="ConstantValue属性"><a href="#ConstantValue属性" class="headerlink" title="ConstantValue属性"></a>ConstantValue属性</h5><p>出现在field_info中，是一个和字段相关的属性，静态基本类型字段或静态String字段会出现，为静态变量提供了一种初始化的方式（另一种是<clinit>初始化方法）</clinit></p><ul><li>结构：<div align="center"><br><img src="https://raw.githubusercontent.com/Tristan-Hou/MarkdownImg/master/res/ConstantValue%E5%B1%9E%E6%80%A7%E7%BB%93%E6%9E%84.jpg" width="200" height="180" alt="" aligh="center/"><br> </div> </li></ul><ul><li><p>constantvalue_index：根据field_info描述的字段的不同， 可以是不同类型的数据项——byte， short， char， int， boolean类型都指向一个CONSTANT_Integer_info（因为虽然java语言支持byte， short， char， boolean类型， 但是JVM却不支持这几种类型，class文件中的常量池中没有和这几个数据类型相对应的数据项， 这几中类型都被JVM在执行时当做int来对待，都对应CONSTANT_Integer_info）</p></li><li><p>代码：</p><pre><code>package com.jg.zhang;  public class Person {     static final int a = 1;     int age;     int getAge(){         return age;     }   } </code></pre><p>反编译：</p><pre><code>Constant pool:  ...    #7 = Utf8         ConstantValue      #8 = Integer      1  ...{      static final int a;          flags: ACC_STATIC, ACC_FINAL          ConstantValue: int 1      ...  }  </code></pre>  <div align="center"><br><img src="https://raw.githubusercontent.com/Tristan-Hou/MarkdownImg/master/res/ConstantValue%E5%B1%9E%E6%80%A7%E5%BC%95%E7%94%A8.jpg" width="500" height="400" alt="" aligh="center/"><br> </div> </li></ul><h5 id="Deprecated属性"><a href="#Deprecated属性" class="headerlink" title="Deprecated属性"></a>Deprecated属性</h5><p>可以出现在filed_info、method_info和顶层的ClassFile中,表示这个字段， 方法或类已经过时.用来支持源文件中的@deprecated注解</p><h5 id="Code属性"><a href="#Code属性" class="headerlink" title="Code属性"></a>Code属性</h5><p>非抽象方法都会有的属性，是方法的一个最重要的属性,存放的是方法的字节码指令和操作数栈，局部变量相关的信息</p> <div align="center"><br>  <img src="https://raw.githubusercontent.com/Tristan-Hou/MarkdownImg/master/res/Code%E5%B1%9E%E6%80%A7%E7%BB%93%E6%9E%84.jpg" width="500" height="400" alt="" aligh="center/"><br>   </div> <ul><li>attribute_name_index：属性名字“Code”</li><li>attribute_length：长度</li><li>max_stack：指定当前方法被执行引擎执行的时候， 在栈帧中需要分配的操作数栈的大小</li><li>max_locals：指定当前方法被执行引擎执行的时候， 在栈帧中需要分配的局部表量表的大小（方法中的局部变量包括方法的参数， 方法的默认参数this， 方法体中定义的变量， catch语句中的异常对象）</li><li>code_length：该方法的字节码的长度，每条字节码占一个字节</li><li>code：字节码指令</li><li>exception_table_length：异常表的大小</li><li>exception_table：对<code>方法体</code>中try-catch_finally的描述，包含exception_info</li><li>attributes_count：</li><li>attributes：存放了Code属性中的其他属性，LineNumberTable和LocalVariableTable</li></ul><h5 id="LineNumberTable属性"><a href="#LineNumberTable属性" class="headerlink" title="LineNumberTable属性"></a>LineNumberTable属性</h5><p>存在于Code属性中，它建立了字节码偏移量到源代码行号之间的联系</p><div align="center"><br>  <img src="https://raw.githubusercontent.com/Tristan-Hou/MarkdownImg/master/res/LineNumberTable%E5%B1%9E%E6%80%A7%E7%BB%93%E6%9E%84.jpg" width="500" height="400" alt="" aligh="center/"><br>   </div> <ul><li>line_number_info 结构描述了一条字节码和源码行号的对应关系</li><li>start_pc描述的字节码指令的偏移量，line_number描述的字节码指令对应的源码中的行号</li></ul><h5 id="LocalVariableTable属性"><a href="#LocalVariableTable属性" class="headerlink" title="LocalVariableTable属性"></a>LocalVariableTable属性</h5><p>存在于Code属性中，方法中的局部变量与源代码中的局部变量之间的对应关系。</p><div align="center"><br>  <img src="https://raw.githubusercontent.com/Tristan-Hou/MarkdownImg/master/res/LocalVariableTable%E5%B1%9E%E6%80%A7%E7%BB%93%E6%9E%84.jpg" width="500" height="400" alt="" aligh="center/"><br>   </div><ul><li>start_pc：局部变量的作用域的起始字节码偏移量</li><li>length：局部变量的作用域的大小——start_pc 到start_pc+length</li><li>name_index：局部变量的变量名</li><li>descriptor_index：局部变量的描述符</li><li>index：该方法被执行时，局部变量在栈帧中局部变量表中的位置</li></ul><h5 id="Exceptions属性"><a href="#Exceptions属性" class="headerlink" title="Exceptions属性"></a>Exceptions属性</h5><p>method_info中的attributes中。描述的是<code>方法声明</code>的可能会抛出的异常。</p><div align="center"><br>  <img src="https://raw.githubusercontent.com/Tristan-Hou/MarkdownImg/master/res/Exceptions%E5%B1%9E%E6%80%A7%E7%BB%93%E6%9E%84.jpg" width="500" height="400" alt="" aligh="center/"><br>   </div><ul><li>number_of_exceptions：</li><li>exceptions_index_table：number_of_exceptions个，每一个指向一个常量池中的CONSTANT_Class_info，描述了一个被抛出的异常的类型</li></ul><h3 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h3><p>知道方法是如何表示的， 字段是如何表示的， 继承是如何表示的 ， 方法体是如何表示的， 等等。 所有源文件中的东西， 都会在class文件中有相应的描述形式</p><div align="center"><br>  <img src="https://raw.githubusercontent.com/Tristan-Hou/MarkdownImg/master/res/method_info%E6%89%80%E6%9C%89%E5%B1%9E%E6%80%A7%E7%BB%93%E6%9E%84%E5%9B%BE.jpg" width="500" height="400" alt="" aligh="center/"><br>   </div>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文主要记录Java中Class文件的结构。&lt;/p&gt;
    
    </summary>
    
      <category term="虚拟机" scheme="http://yoursite.com/categories/%E8%99%9A%E6%8B%9F%E6%9C%BA/"/>
    
    
      <category term="虚拟机" scheme="http://yoursite.com/tags/%E8%99%9A%E6%8B%9F%E6%9C%BA/"/>
    
  </entry>
  
  <entry>
    <title>Android逆向分析笔记(2)</title>
    <link href="http://yoursite.com/2018/01/07/Android%E9%80%86%E5%90%91%E5%88%86%E6%9E%90%E7%AC%94%E8%AE%B0(2)/"/>
    <id>http://yoursite.com/2018/01/07/Android逆向分析笔记(2)/</id>
    <published>2018-01-07T13:21:52.557Z</published>
    <updated>2018-01-07T16:12:03.855Z</updated>
    
    <content type="html"><![CDATA[<p>笔记二主要记录dex文件格式，以及关于Android静态分析的知识点。<br><a id="more"></a></p><h2 id="dex文件格式与class文件格式"><a href="#dex文件格式与class文件格式" class="headerlink" title="dex文件格式与class文件格式"></a>dex文件格式与class文件格式</h2><h2 id="静态分析Android程序"><a href="#静态分析Android程序" class="headerlink" title="静态分析Android程序"></a>静态分析Android程序</h2><h3 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h3><pre><code>class Outer{    class Inner{}}//baksmali反编译后产生Outer$Inner.smali文件，打开，部分代码：...# instance field.field final synthetic this$0:L(package)Outer;</code></pre><p>synthetic属性代表这是被编译器合成的、虚构的，程序员本人并没有声明过该字段<br>this代表父类的引用，0表示引用的层数：</p><pre><code>public class Outer {                     //this$0    public class FirstInner {            //this$1        public class SecondInner {       //this$2            public class ThirdInner {}        }    }}</code></pre><h3 id="smali"><a href="#smali" class="headerlink" title="smali"></a>smali</h3><h2 id="ARM"><a href="#ARM" class="headerlink" title="ARM"></a>ARM</h2><h3 id="家族"><a href="#家族" class="headerlink" title="家族"></a>家族</h3><ul><li>Classic、Emnedded、Application三大家族</li><li>Classic： ARM1~ARM11，之后采用Cortex命名</li><li>Cortex型号：<ul><li>Cortex-A系列：智能手机、上网本、数字电视等。A8、A9、A10处理器</li><li>Cortex-M系列：微控制器，高能效、低功耗</li><li>Cortex-R系列</li></ul></li><li><p>相同版本处理器采用同一套ARM指令集：</p><p>| 架构 | 处理器家族 |<br>|——-| ——-|<br>|ARMv1 | ARM1 |<br>|ARMv2 | ARM2、ARM3 |<br>|ARMv3 | ARM6、ARM7 |<br>|ARMv4 | StribgARM、ARM7TDMI、ARM9TDMI |<br>|ARMv5 | ARM7EJ、ARM9E、ARM10E、XScale |<br>|ARMv6 | ARM11、ARMCortex-M |<br>|ARMv7 | ARM Cotex-A、ARM Cotex-M、ARM Cotex-R |<br>|ARMv8 | 32位、64位—进入64位时代|</p><p>ARMv7架构加入了VFPv3与NEON支持。NEON技术扩展了SIMD，加入了许多多媒体格式的硬编码，如：MPEG-4、H.264等。</p></li></ul><h3 id="原生程序的生成"><a href="#原生程序的生成" class="headerlink" title="原生程序的生成"></a>原生程序的生成</h3><p>C/C++在安卓中会生成ARM elf可执行文件。gcc编译原生c代码步骤：</p><ol><li>预处理：编译器将处理C代码中的预处理命令，#include、#defice等。(gcc -E hello.c -o hello.i)</li><li>编译：gcc检查代码规范性、语法错误等，随后将代码翻译成ARM汇编语言代码(gcc -S hello.i -o hello.s)</li><li>汇编：gcc调用汇编器将汇编代码汇编成二进制目标文件(gcc -c hello.s -o hello.o)</li><li>链接：编译器调用链接器将二进制目标文件连接成Android平台可执行的ARM原生程序(gcc hello.o -o hello)</li></ol><h3 id="NEON、VFP"><a href="#NEON、VFP" class="headerlink" title="NEON、VFP"></a>NEON、VFP</h3><p>ARMv7后加入了NEON指令集。如果想要使用，需要在Android.mk中加入一行“LOCAL_ARM_NEON := true”，还需要设置TARGET_ARCH_ABI值为armeabi-v7a。</p><p>可能有些手机还是不支持NEON和VFP，NDK中提供了一个cpufeatures库来检测。在Android.mk中加入“$(call import-module,android/cpufeatures)”，然后再C/C++代码头文件包含“cpu-feature.h”，它包含了android_getCpuFamily()、android_getCpuFeatures()、android_getCpuCount()。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;笔记二主要记录dex文件格式，以及关于Android静态分析的知识点。&lt;br&gt;
    
    </summary>
    
      <category term="Android" scheme="http://yoursite.com/categories/Android/"/>
    
    
      <category term="Dalvik虚拟机" scheme="http://yoursite.com/tags/Dalvik%E8%99%9A%E6%8B%9F%E6%9C%BA/"/>
    
  </entry>
  
  <entry>
    <title>零零碎碎的知识点</title>
    <link href="http://yoursite.com/2018/01/06/%E9%9B%B6%E9%9B%B6%E7%A2%8E%E7%A2%8E%E7%9A%84%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
    <id>http://yoursite.com/2018/01/06/零零碎碎的知识点/</id>
    <published>2018-01-06T09:28:39.102Z</published>
    <updated>2018-01-14T14:48:05.563Z</updated>
    
    <content type="html"><![CDATA[<p>学习过程中总是有一些杂七杂八的知识点，不太常用，却偶尔需要。跟大知识点放在一起时间久了不容易找，因此都放在这里。<br><a id="more"></a></p><h2 id="Java相关"><a href="#Java相关" class="headerlink" title="Java相关"></a>Java相关</h2><ol><li>方法描述符与方法签名：<a href="http://jianleixing.iteye.com/blog/2017732" target="_blank" rel="noopener">描述符与特征签名的区别</a>，特别注意泛型的影响</li><li>Android Studio下lint使用：(./gradlew :项目名:lint<code>Flavors名``buildTypes名</code>)./gradlew :Player_ad:lintNeon_market_D</li></ol><h2 id="NDK相关"><a href="#NDK相关" class="headerlink" title="NDK相关"></a>NDK相关</h2><ol><li>mk文件：隔离cpu、平台、ABI等差异，指出那些文件需要编译，编译特性要求等，帮助NDK实现交叉编译，创建so文件。</li><li>API：libc（C标准库）、libm（标准数学库）、libz（压缩库）、liblog（log库）。</li><li>android.useDeprecatedNdk=true 可配置在local.properties中，支持低版本编译</li><li><p>关于JNIEnv：</p><ul><li>C中：JNIEnv是一个结构体指针的别名，env是二级指针，一般用法需要传入env，例如：(*env)-&gt;NewStringUTF(env, “string”);</li><li>C++中：JNIEnv是一个结构体的别名，env是一级指针，使用时一般不需要传入env(因为C++中有this指针，代表着调用这functions的指针（其实就是二级指针）)，例如：env-&gt;NewStringUTF(“string”);</li><li><p>jdk的jni.h中：</p><p>   #ifdef __cplusplus</p><pre><code>typedef JNIEnv_ JNIEnv;</code></pre><p>   #else</p><pre><code>typedef const struct JNINativeInterface_ *JNIEnv;</code></pre><p>   #endif</p></li></ul><p>如果是C，JNIEnv就是JNINativeInterface<em>结构体的指针别名，如果是C++，JNIEnv就是JNIEnv</em>结构体的别名（JNIEnv封装了JNINativeInterface_)</p></li><li></li></ol><h2 id="C语言相关"><a href="#C语言相关" class="headerlink" title="C语言相关"></a>C语言相关</h2><ol><li><p>标准循环写法：</p><pre><code>int i=0;for(; i&lt;n; i++) {    printf(&quot;%d\n&quot;, i);}</code></pre><p>循环变量要抽取出来，否则在linux环境下gcc编译，报错</p></li><li>可以为一个指针变量赋值为NULL，NULL指针又叫空指针，定义在标准库中，值为0。操作系统中0地址通常不允许访问，因此指针被赋为NULL代表它不包含任何东西。</li><li>内存分配函数：<ul><li>void calloc(int num, int size):内存中动态分配num个长度为size的连续空间，初始化为0；</li><li>void free(void *address):释放address所指向的内存块，动态释放</li><li>void *malloc(int num):堆区释放一块指定大小的内存空间，数据不会初始化，值未知</li><li>void <em>relloc(void </em>address, int newsize):重新分配address内存，扩展到newsize大小</li></ul></li><li>关于relooc：<ul><li>如果当前内存段后面有需要的内存空间，且空闲空间足够，则扩展内存空间，返回原指针</li><li>如果当前内存段后的空闲空间不够，则使用堆中第一个能够满足这个要求的内存块，将目前的数据复制到性的位置，并将原内存段释放掉，返回新地址</li><li>如果申请失败，返回空指针NULL</li><li>释放内存时，只需要释放relloc返回的内存地址。因为原地址要么与relloc返回的地址相同，要么在重新分配新地址后，已经被释放</li></ul></li><li><p>内存泄漏：内存没有被释放（*p被赋新值前没有free()和置为NULL）</p><pre><code>void main() {    int *p = (int *)malloc(1024*1024*10*sizeof(int));    //free(p);    //p = NULL;    printf(&quot;%#x\n&quot;, p);    p = (int *)malloc(1024*1024*10*sizeof(int)*2);    free(p);    p = NULL;    printf(&quot;%#x\n&quot;, p);    getchar();}</code></pre></li><li>结构体大小：由于字节对齐，结构体变量大小，必须是最宽的基本数据类型的整数倍（空间换时间）</li><li>tyoedef：可以用来定义与平台无关的类型<ul><li>typedef long double REAL：支持long double的平台</li><li>typedef double REAL：不支持long double，支持double的平台</li><li>typedef float REAL：只支持float的平台</li><li>跨平台时，利用typedef可以很方便的修改代码</li><li>标准库中就使用了这个技巧，例如：size_t</li></ul></li><li>文件：<ul><li>写文本时，每遇到一个’\n’，会将其转换成’\r\n’(回车换行)。</li><li>读文本时，每遇到一个’\r\n’，会将其转换成’\n’。</li><li>但是读写二进制文件的时候并不会做以上转换。</li></ul></li><li><p>预处理器：文本替换工具，指示编译器在实际编译之前完成所需的预处理。</p><p>| 指令 |  描述 |<br>|—–| —–|<br>| #define | 定义宏 |<br>| #include | 包含一个源代码文件|<br>| #undef | 取消已定义的宏 |<br>| #ifdef | 如果宏已经定义，返回真 |<br>| #ifndef | 如果宏没有定义，返回假 |<br>| #if | 如果给定条件为真，则编译下面的代码 |<br>| #else #if |<br>| #elif | 如果前面的#if给定条件不为真，当前条件为真，则编译下面代码|<br>| #endif | 结束一个#if…#else条件编译块 |<br>| #error |当遇到标准错误时，输出错误消息 |<br>| #pragma | 使用标准化方法，向编译器发布特殊的命令到编译器中 |</p></li><li><p>&lt;&gt;表示引入的是系统头文件，“”表示引入得失第三方头文件</p></li></ol><h2 id="C-相关"><a href="#C-相关" class="headerlink" title="C++相关"></a>C++相关</h2><ol><li><p>命名空间：</p><pre><code>namespace namespace_name {   // 代码声明}</code></pre><p>调用：</p><pre><code>name::code;  // code 可以是变量或函数</code></pre><p>实例：</p><pre><code>#include &lt;iostream&gt;using namespace std;// 第一个命名空间namespace first_space{    void func(){       cout &lt;&lt; &quot;Inside first_space&quot; &lt;&lt; endl;    }}// 第二个命名空间namespace second_space{    void func(){       cout &lt;&lt; &quot;Inside second_space&quot; &lt;&lt; endl;    }}//using namespace first_space;void main (){    // 调用第一个命名空间中的函数   // func();   first_space::func();    // 调用第二个命名空间中的函数    second_space::func();    system(&quot;pause&quot;);}//结果输出：Inside first_spaceInside second_space</code></pre><p>嵌套的命名空间:</p><pre><code>namespace namespace_name1 {   // 代码声明   namespace namespace_name2 {      // 代码声明   }}</code></pre><p>可以访问namespace2里的成员：</p><pre><code>#include &lt;iostream&gt; using namespace std; // 第一个命名空间 namespace first_space{    void func(){       cout &lt;&lt; &quot;Inside first_space&quot; &lt;&lt; endl;    }    // 第二个命名空间    namespace second_space{       void func(){          cout &lt;&lt; &quot;Inside second_space&quot; &lt;&lt; endl;       }    } } using namespace first_space::second_space; int main (){    // 调用第二个命名空间中的函数    func();    system(&quot;pause&quot;);    return 0; } //结果输出： Inside second_space</code></pre></li><li></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;学习过程中总是有一些杂七杂八的知识点，不太常用，却偶尔需要。跟大知识点放在一起时间久了不容易找，因此都放在这里。&lt;br&gt;
    
    </summary>
    
      <category term="其他" scheme="http://yoursite.com/categories/%E5%85%B6%E4%BB%96/"/>
    
    
      <category term="零碎知识" scheme="http://yoursite.com/tags/%E9%9B%B6%E7%A2%8E%E7%9F%A5%E8%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>Android逆向分析笔记(1)</title>
    <link href="http://yoursite.com/2018/01/01/Android%E9%80%86%E5%90%91%E5%88%86%E6%9E%90%E7%AC%94%E8%AE%B0(1)/"/>
    <id>http://yoursite.com/2018/01/01/Android逆向分析笔记(1)/</id>
    <published>2018-01-01T13:04:55.021Z</published>
    <updated>2018-01-07T13:24:06.545Z</updated>
    
    <content type="html"><![CDATA[<p>最近在读《Android软件安全与逆向分析》，虽然不从事逆向研究的工作，但作为一名Android开发者，觉得了解一下相关知识还是有必要的。因此，这里记录下该书所阐述的主要知识点，方便记忆和理解。<br><a id="more"></a></p><h2 id="Dalvik虚拟机与Java虚拟机"><a href="#Dalvik虚拟机与Java虚拟机" class="headerlink" title="Dalvik虚拟机与Java虚拟机"></a>Dalvik虚拟机与Java虚拟机</h2><h3 id="区别："><a href="#区别：" class="headerlink" title="区别："></a>区别：</h3><ol><li>Java： 代码-编译-java字节码-class文件，虚拟机解码class文件<br>Dalvik：java字节码-Dalvik字节码-Dex，虚拟机解释Dex文件</li><li><p>Dalvik文件体积更小</p><ul><li>dx工具将java字节码-Dalvik字节码</li><li>dx工具对java文件重新排序，消除类文件中的冗余信息</li><li>例如：<ul><li>多个类文件相互引用，被引用的类文件中的方法签名会复制到引用类文件中;</li><li>常量字符串在多个类中也会被重复引用</li></ul></li><li>dx工具分解常量池，所有文件共享一个常量池</li></ul><p>class文件结构:<br><img src="https://raw.githubusercontent.com/Tristan-Hou/MarkdownImg/master/res/20151231114022450.png" alt=""></p></li></ol><p> <img src="https://raw.githubusercontent.com/Tristan-Hou/MarkdownImg/master/res/1514813806959.jpg" alt=""></p><ol><li><p>Java: 基于栈架构，需要频繁读写数据<br>Dalvik：寄存器架构，数据访问通过寄存器直接传递（lua的VM也是寄存器实现)</p><ul><li>无论是栈虚拟机，还是寄存器虚拟机，都要：<ul><li>将源码编译为VM指定的字节码</li><li>包含操作数，指令(处理操作数运算)，操作数数据结构</li><li>一个为所有函数操作的调用栈</li><li>指向下一条将要执行的指令位置的指令指针（PC计数器)——类似ARM架构cpu的PC寄存器与x86架构cpu的IP寄存器</li><li>操控指令的虚拟CPU<ul><li>根据PC计数器获取下一条指令</li><li>解析指令的具体含义(+/-/*/‘/等)</li><li>执行指令</li></ul></li></ul></li><li>注意：<ul><li>两种虚拟机都一个PC计数器和调用栈：<ul><li>Java：记录方法的调用，调用方法压入一帧，方法完成弹出。每一帧包括局部变量区(方法参数、局部变量)和求职栈(求值中间结果、别的方法参数)</li><li>Dalvik: 调用栈只维护一个寄存器列表</li></ul></li></ul></li></ul><p>示例代码：</p><pre><code>public class Hello {    public int foo(int a, int b) {        return (a + b) * (a - b);    }    public static void main(String[] argc) {        Hello hello = new Hello();        System.out.println(hello.foo(5, 3));    }}</code></pre><p>dx –dex –output=Hello.dex Hello.class可生成dex文件<br>javap -c -classpath . Hello查看foo的Java字节码：<br><img src="https://raw.githubusercontent.com/Tristan-Hou/MarkdownImg/master/res/1514822513334.jpg" alt=""><br>每条指令占1个字节，共8字节。<br>dexdump查看foodalvik字节码：<br><img src="https://raw.githubusercontent.com/Tristan-Hou/MarkdownImg/master/res/1514822614888.jpg" alt=""></p><ul><li>java虚拟机：更多的指令、更多的cpu消耗、更具可移植性</li><li>Dalvik：更多的指令空间、数据缓冲更易失效、更有利于进行AOT（ahead-of-time）优化（相对JIT）</li></ul></li></ol><h3 id="Dalvik寄存器"><a href="#Dalvik寄存器" class="headerlink" title="Dalvik寄存器"></a>Dalvik寄存器</h3><ul><li>ARM架构：Dalvik部分寄存器映射到ARM寄存器上，部分通过调用栈模拟</li><li>32位寄存器，64位通过连续的两个寄存器实现</li><li>根据Dalvik指令表，一共有2的16次方，0~65535个寄存器</li><li>每个虚拟机为一个进程维护一个调用栈，每个函数在函数头使用.registers指令指定用到的寄存器数目，虚拟机为其分配占空间，模拟寄存器。</li></ul><h2 id="Dalvik虚拟机特性"><a href="#Dalvik虚拟机特性" class="headerlink" title="Dalvik虚拟机特性"></a>Dalvik虚拟机特性</h2><h3 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h3><ul><li><p>内存分类：Java Object Heap、Bitmap Memory、Native Heap</p><ul><li>Java Object Heap：<ul><li>Java <code>new</code>出来的对象都存在这里。</li><li>Xms和Xmx分别控制最大/小值</li><li>为了避免Dalvik运行时不断调整此Heap大小而影响性能，一般让Xms=Xmx</li><li>ActivityManager.getMemoryClass获得该值。这个Java Object Heap就是平日所说的<code>Android应用程序进程能够使用的最大内存</code></li></ul></li></ul><p>代码：</p><pre><code>public class ActivityManager { /** * Return the approximate per-application memory class of the current * device.  This gives you an idea of how hard a memory limit you should * impose on your application to let the overall system work best.  The * returned value is in megabytes; the baseline Android memory class is * 16 (which happens to be the Java heap limit of those devices); some * device with more memory may return 24 or even higher numbers. */      public int getMemoryClass() {            return staticGetMemoryClass();        }      /** @hide */        static public int staticGetMemoryClass() {        // Really brain dead right now -- just take this from the configured        // vm heap size, and assume it is in megabytes and thus ends with &quot;m&quot;.            String vmHeapSize = SystemProperties.get(&quot;dalvik.vm.heapsize&quot;, &quot;16m&quot;);            return Integer.parseInt(vmHeapSize.substring(0, vmHeapSize.length()-1)); }  </code></pre><ul><li>Bitmap Memory:<ul><li>3.1之前，在Native Heap分配，但是同样算入Java Object Heap中，因此Bitmap+Java Object&lt;=Xmx</li><li>3.1之后，直接放入Java Object Heap，接受Gc管理</li></ul></li><li>Native Heap：<ul><li>malloc()分配。不收Gc限制。</li><li>Android内部代码使用了大量<code>智能指针</code>避免内存泄漏</li></ul></li></ul></li></ul><h3 id="GC"><a href="#GC" class="headerlink" title="GC"></a>GC</h3><ul><li>2.3之前：<ul><li>Stop-the-world，垃圾收集线程在执行时，其它线程都停止</li><li>Full heap collection，一次收集完全部的垃圾</li><li>程序中止通常大于100ms</li></ul></li><li>2.3之后：<ul><li>Cocurrent，垃圾收集线程与其它线程是并发执行的</li><li>Partial collection，一次可能只收集一部分垃圾</li><li>程序中止通常都小于5ms</li></ul></li></ul><p>Gc日志：</p><pre><code>D/dalvikvm(9050): GC_CONCURRENT freed 2049K, 65% free 3571K/9991K, external 4703K/5261K, paused 2ms+2ms</code></pre><ul><li>GC_CONCURRENT：GC原因</li><li>2049K：总共回收的内存</li><li>3571K/9991K：在9991K的Java Object Heap中，3571K正在使用的</li><li>4703K/5261K：在5261K的External Memory中，4703K正在使用的</li><li>2ms+2ms：垃圾收集造成的程序中止时间</li></ul><h3 id="JIT"><a href="#JIT" class="headerlink" title="JIT"></a>JIT</h3><ul><li>运行时编译，可以有效优化代码，但是占用运行时。</li><li>2-8原则：80%时间重复运行20%代码，因此只JIT这20%代码</li><li>假设某种情况，并作出代码优化–这种假设成立，保持现状–假设不成立，调整策略–只要假设不成立的情况很少发生或不发生，就会获得巨大收益–Gambing</li><li>例子：<ul><li>Java的同步，Lock和Unlock操作是非常耗时的，多线程环境下需要这种操作</li><li>但有些程序(同步块、同步函数)，很可能始终保持着单线程执行状态</li><li>JIT采取一种Lazy Unlocking机制：<ul><li>线程T1执行同步代码块C，先按照正常流程获取轻量级锁L1，线程T1的ID会记录在L1上</li><li>当T1离开C时，并不释放L1</li><li>当T1再次进入C，发现L1所有者就是自己，直接执行C</li><li>此时另一个线程T2需要执行C，发现L1已经被T1占有</li><li>JIT检查T1调用堆栈，查看T1是否还在执行C</li><li>是，将轻量级锁L1转换为重量级锁L2，将L2状态设置为锁定，再让T2在L2上睡眠</li><li>T1执行完C后，按正常流程释放L2，从而唤醒T2，执行C</li><li>否，直接将L1所有者标记为T2，T2执行C</li></ul></li></ul></li><li>静态语言无法这么做。”从这个角度来看，我们就可以说，静态编译语言（如C++）并不一定比在虚拟机上执行的语言（如Java）快，这是因为后者可以有一种强大的武器叫做JIT”——罗升阳</li><li><a href="http://blog.reverberate.org/2012/12/hello-jit-world-joy-of-simple-jits.html" target="_blank" rel="noopener">JIT实现原理简要介绍</a></li></ul><h3 id="NDK"><a href="#NDK" class="headerlink" title="NDK"></a>NDK</h3><h3 id="进程和线程管理"><a href="#进程和线程管理" class="headerlink" title="进程和线程管理"></a>进程和线程管理</h3><p>老罗看过Linux内核的几本书<a href="http://blog.csdn.net/luoshengyang/article/details/6557518" target="_blank" rel="noopener">老罗的Android学习之路</a><br><a href="https://dl.packetstormsecurity.net/papers/general/Abstract-Processor.pdf" target="_blank" rel="noopener">怎么实现一个虚拟的CPU</a></p><h2 id="Android程序的安装流程"><a href="#Android程序的安装流程" class="headerlink" title="Android程序的安装流程"></a>Android程序的安装流程</h2><ol><li>系统程序：开机时安装，没有安装界面。开机时启动PackageManagerService服务，扫描/system/app重新安装所有程序<ul><li>Zygote进程–SystemServer组件–PackageManagerService：<br><img src="https://raw.githubusercontent.com/Tristan-Hou/MarkdownImg/master/res/0_1315661784a77A.gif" alt=""><br>图片来源：<a href="http://blog.csdn.net/luoshengyang/article/details/6766010" target="_blank" rel="noopener">Android应用程序安装过程源代码分析</a></li></ul></li><li>Android市场安装：网络安装，没有安装界面。</li><li>Adb：没有安装界面</li><li>SD卡：apk文件安装，有安装界面。调用Android系统软件包packageinstall.apk安装。<ul><li>当点击apk，进入安装页面时，实际上就是启动了packageinstall.apk的PackageInstallerActivity，通过初始化PagcageManager和PackageParser.Packager对象，通过PackageUtil.getPackageInfo()解析程序包信息，主要解析Menifest.xml中的标签信息。失败，返回；成功，setContentView显示安装界面。</li><li>点击安装按钮–startActivity–InstallAppProgress.class–PackageManager.installPackage()。这个方法最终通过PackageManagerService.java实现。总之，通过installPackage()，进行了程序安装权限验证，随后进行安装或替换。</li><li>安装过程中会通过scanPackageLI()完成apk依赖库检测、签名验证、sharedUser的签名检查、更新Native库目录文件、组件名称检查等，这些都完成后，通过mInstaller.install()安装程序</li><li>install()构造字符串“install name uid gid”–transaction()–通过socket发送install指令–/system/bin/installd(常驻内存)–install指令函数installd.c do_install() install()–创建包路径/创建库路径/创建包目录/设置包目录权限/创建库目录/设置库目录权限/设置库目录所有者/设置包目录所有者–socket回传结果–成功/失败</li></ul></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近在读《Android软件安全与逆向分析》，虽然不从事逆向研究的工作，但作为一名Android开发者，觉得了解一下相关知识还是有必要的。因此，这里记录下该书所阐述的主要知识点，方便记忆和理解。&lt;br&gt;
    
    </summary>
    
      <category term="Android" scheme="http://yoursite.com/categories/Android/"/>
    
    
      <category term="Dalvik虚拟机" scheme="http://yoursite.com/tags/Dalvik%E8%99%9A%E6%8B%9F%E6%9C%BA/"/>
    
  </entry>
  
  <entry>
    <title>音视频学习（1）：基础概念</title>
    <link href="http://yoursite.com/2017/12/29/ffmpeg-1/"/>
    <id>http://yoursite.com/2017/12/29/ffmpeg-1/</id>
    <published>2017-12-29T07:37:30.869Z</published>
    <updated>2017-12-29T07:37:30.869Z</updated>
    
    <content type="html"><![CDATA[<h2 id="视频格式"><a href="#视频格式" class="headerlink" title="视频格式"></a>视频格式</h2><p>主流编码格式有H.261/H.263/H.264/H.265，运动静止图像专家组的M-JPEG和国际标准化组织运动图像专家组的MPEG系列标准，还有Real-Networks的RealVideo、微软的WMV和苹果的QuickTime等。目前主要学习<code>H264</code></p><a id="more"></a><ul><li><code>低码率</code>：同等图像质量数据量只有MPEG2的1/8，MPEG4的1/3</li><li><code>高质量</code>：连续、流畅的高质量图像（DVD质量）</li><li><code>容错能力强</code>：提供了在不稳定网络环境下容易发生的丢包等错误的必要工具</li><li><code>网络适应性强</code>：H.264提供了网络抽象层，似的H.264的文件能容易的在不同网络上传输（互联网、CDMA、GPRS、WCDMA、CDMA2000等）</li><li><code>高压缩率</code>：压缩比可达到102：1（同等图像质量，是MPEG2的2倍以上，MPEG4的1.5~2倍——原始文件大小88G，MPEG2压缩后变成3.5G，压缩比25：1，而H.264压缩后为879M）</li></ul><h2 id="音频格式"><a href="#音频格式" class="headerlink" title="音频格式"></a>音频格式</h2><ul><li>采样率：模-数转换过程中单位时间内采样次数</li><li>单声道声音文件：采样数据为8位的短整数（short int 00H-FFH）</li><li>双声道立体声文件：每次采样数据为一个16位的整数（int），高8位为左声道，低8位为右声道</li></ul><p>采样记录的是振幅，因此：</p><ul><li>1字节（8bit）只能记录256个数</li><li>2字节（16bit）可以记录65536个数，属于CD标准</li><li>4字节（32bit）没必要</li></ul><p>可根据mav文件大小、采样率、采样大小估算播放时长：424.644字节，“属性-&gt;摘要”里看到“22050Hz/16bit/立体声”，因此每秒传输速率就是22050 <em> 16 </em> 2 = 705600（bit/s)，字节：705600 / 8 = 88200（字节/s)。而包装标准PCM（脉冲编码调制）格式的WAVE文件（<em>.wav）中至少带有42个字节头信息，所以播放时长为：<br>（424644 - 42） / (22050 </em> 16 * 2 / 8) ≈ 4.8140816s</p><p>上面例子中，705600（bit/s)也叫<code>比特率/取样率</code> kbps/bps。压缩的音频文件常用位速表示，cd音质的MP3是:128kbps/44100Hz。</p><p>PCM采样顺序图：<br><img src="https://raw.githubusercontent.com/Tristan-Hou/MarkdownImg/master/res/31215112_8x2j37.gif" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;视频格式&quot;&gt;&lt;a href=&quot;#视频格式&quot; class=&quot;headerlink&quot; title=&quot;视频格式&quot;&gt;&lt;/a&gt;视频格式&lt;/h2&gt;&lt;p&gt;主流编码格式有H.261/H.263/H.264/H.265，运动静止图像专家组的M-JPEG和国际标准化组织运动图像专家组的MPEG系列标准，还有Real-Networks的RealVideo、微软的WMV和苹果的QuickTime等。目前主要学习&lt;code&gt;H264&lt;/code&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="FFmpeg" scheme="http://yoursite.com/categories/FFmpeg/"/>
    
    
      <category term="FFmpeg" scheme="http://yoursite.com/tags/FFmpeg/"/>
    
      <category term="音视频" scheme="http://yoursite.com/tags/%E9%9F%B3%E8%A7%86%E9%A2%91/"/>
    
  </entry>
  
  <entry>
    <title>Xndroid学习篇(1)——初次编译</title>
    <link href="http://yoursite.com/2017/12/29/Xndroid-learn-1/"/>
    <id>http://yoursite.com/2017/12/29/Xndroid-learn-1/</id>
    <published>2017-12-29T07:37:30.868Z</published>
    <updated>2017-12-29T07:37:30.869Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul><li>项目地址：<a href="https://github.com/XndroidDev/Xndroid" target="_blank" rel="noopener">Xndroid</a></li><li>作者：<a href="https://github.com/XndroidDev" target="_blank" rel="noopener">XndroidDev</a></li></ul><h3 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h3><p>首次fork该项目，并进行编译时，编译时不能通过的我用的是最新的Andorid Studio 3.0）——当然有一个原因是我的NDK路径不对，汗~     </p><a id="more"></a><ul><li>首先，直接sync会报错： </li></ul><p><img src="https://raw.githubusercontent.com/Tristan-Hou/MarkdownImg/master/res/xndroid-shrinker-error.jpg" alt=""></p><blockquote><p>Error:Resource shrinker cannot be used for libraries.</p></blockquote><p>原因是library中使用了混淆，并移除了无用的资源文件，解决办法就是把该library中的<code>shrinkResources</code>字段移除——按理说这个字段应该加上，但没想到其他更好的办法，暂时移除吧。 </p><p>接下来应该可以sync成功了。</p><ul><li>随后开始编译，编译失败：</li></ul><p><img src="https://raw.githubusercontent.com/Tristan-Hou/MarkdownImg/master/res/xndroid-compileNdk.jpg" alt=""></p><blockquote><p>:app:ompileDebugNdk</p></blockquote><p>根据提示，我们可以知道这是由于<code>gradle.properties</code>文件中使用了<code>useDeprecatedNdk</code>，而这个东西已经“no longer supported and will removed in the next version”。所以我们有两个解决办法：</p><ol><li>使用<code>CMake</code> 和 <code>ndk-build integration</code>;</li><li>使用<code>android.deprecatedNdkCompileLease=xxx</code>这么一个东西，“for another 60 days”</li></ol><p>我们先实验第二种方法，直接添加“android.deprecatedNdkCompileLease=1511832698813”到gradle.properties文件中，编译成功。</p><p>但是这种方法貌似只能延续60天？那60天后呢？所以为了长久之计，我们还是该使用第一种方法——CMake。</p><hr><p>我是参考这个人的博客<a href="http://blog.csdn.net/qiantanlong/article/details/78622990" target="_blank" rel="noopener">《NDK开发之——Error: Flag android.useDeprecatedNdk is no longer supported爬坑》</a>实现的。具体做法就是：</p><ol><li><p>先将app项目下的<code>build.gradle</code>文件内容按该博客所讲，补齐。</p><pre><code>android {    compileSdkVersion 26    buildToolsVersion &apos;26.0.2&apos;    defaultConfig {        applicationId &quot;net.xndroid&quot;        minSdkVersion 14        targetSdkVersion 26       ndk {          moduleName &quot;sockvpn&quot;  //设置库(so)文件名称          //设置支持的so库架构          abiFilters &quot;armeabi-v7a&quot;, &quot;arm64-v8a&quot;, &quot;armeabi&quot;          ldLibs &quot;log&quot;      }      externalNativeBuild {          cmake {              cppFlags &quot;&quot;          }      }    versionCode 13    versionName &quot;1.1.3-3&quot;    testInstrumentationRunner &quot;android.support.test.runner.AndroidJUnitRunner&quot;    }    buildTypes {        release {            minifyEnabled false            proguardFiles getDefaultProguardFile(&apos;proguard-android.txt&apos;), &apos;proguard-rules.pro&apos;        }    }    sourceSets.main {        jniLibs.srcDirs = [&apos;src/main/jni&apos;]    }    externalNativeBuild {        cmake {            path &quot;CMakeLists.txt&quot;        }    }}</code></pre></li></ol><p>其中<code>moduleName &quot;sockvpn&quot;</code>对应了<code>src/main/jni</code>下的<code>sockvpn</code>文件名，也就是编译出来侯的.so文件名，当然你可以起其他名字。</p><p><code>jniLibs.srcDirs = [&#39;src/main/jni&#39;]</code>是你的jni路径。当然你也看到了，这里还有一个文件<code>CMakeLists.txt</code>，你需要在app项目的根目录创建它。</p><ol><li><p>创建<code>CMakeLists.txt</code>：</p><pre><code># For more information about using CMake with Android Studio, read the# documentation: https://d.android.com/studio/projects/add-native-code.html# Sets the minimum version of CMake required to build the native library.cmake_minimum_required(VERSION 3.4.1)# Creates and names a library, sets it as either STATIC# or SHARED, and provides the relative paths to its source code.# You can define multiple libraries, and CMake builds them for you.# Gradle automatically packages shared libraries with your APK.add_library( # Sets the name of the library.             sockvpn             # Sets the library as a shared library.             SHARED             # Provides a relative path to your source file(s).             src/main/jni/sockvpn.c )# Searches for a specified prebuilt library and stores the path as a# variable. Because CMake includes system libraries in the search path by# default, you only need to specify the name of the public NDK library# you want to add. CMake verifies that the library exists before# completing its build.find_library( # Sets the name of the path variable.              log-lib              # Specifies the name of the NDK library that              # you want CMake to locate.              log )# Specifies libraries CMake should link to your target library. You# can link multiple libraries, such as libraries you define in this# build script, prebuilt third-party libraries, or system libraries.target_link_libraries( # Specifies the target library.                       sockvpn                       # Links the target library to the log library                       # included in the NDK.                       ${log-lib} )</code></pre><p>你只需要将上面博客里所讲的一些模块名字改为<code>sockvpn</code>即可。</p></li></ol><p>至于他说的<code>native-lib.cpp</code>，我们不需要。</p><ol><li>编译，成功。<br><img src="https://raw.githubusercontent.com/Tristan-Hou/MarkdownImg/master/res/xndroid-compile-success.jpg" alt=""></li></ol><p>##总结<br>刚开始接触NDK，很多东西都不懂，因此这么一个小小的编译，都浪费了许多时间。<br>这里所说的<code>CMakeLists.txt</code>内容，我并不能完全懂，还有项目里的<code>Android.mk</code>/<code>Application.mk</code>，我也不是很懂。<br><code>所以说，还是要多学习一个啊！提高姿势水平~</code></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;项目地址：&lt;a href=&quot;https://github.com/XndroidDev/Xndroid&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Xndroid&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;作者：&lt;a href=&quot;https://github.com/XndroidDev&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;XndroidDev&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;编译&quot;&gt;&lt;a href=&quot;#编译&quot; class=&quot;headerlink&quot; title=&quot;编译&quot;&gt;&lt;/a&gt;编译&lt;/h3&gt;&lt;p&gt;首次fork该项目，并进行编译时，编译时不能通过的我用的是最新的Andorid Studio 3.0）——当然有一个原因是我的NDK路径不对，汗~     &lt;/p&gt;
    
    </summary>
    
      <category term="NDK" scheme="http://yoursite.com/categories/NDK/"/>
    
    
      <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
      <category term="NDK" scheme="http://yoursite.com/tags/NDK/"/>
    
  </entry>
  
</feed>
